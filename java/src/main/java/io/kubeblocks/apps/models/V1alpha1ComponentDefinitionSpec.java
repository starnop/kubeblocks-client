/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.27.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.kubeblocks.apps.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubeblocks.apps.models.V1alpha1ClusterDefinitionSpecComponentDefsInnerConfigSpecsInner;
import io.kubeblocks.apps.models.V1alpha1ClusterDefinitionSpecComponentDefsInnerLogConfigsInner;
import io.kubeblocks.apps.models.V1alpha1ClusterDefinitionSpecComponentDefsInnerMonitor;
import io.kubeblocks.apps.models.V1alpha1ClusterDefinitionSpecComponentDefsInnerScriptSpecsInner;
import io.kubeblocks.apps.models.V1alpha1ClusterDefinitionSpecComponentDefsInnerServiceRefDeclarationsInner;
import io.kubeblocks.apps.models.V1alpha1ComponentDefinitionSpecExporter;
import io.kubeblocks.apps.models.V1alpha1ComponentDefinitionSpecHostNetwork;
import io.kubeblocks.apps.models.V1alpha1ComponentDefinitionSpecLifecycleActions;
import io.kubeblocks.apps.models.V1alpha1ComponentDefinitionSpecPolicyRulesInner;
import io.kubeblocks.apps.models.V1alpha1ComponentDefinitionSpecReplicasLimit;
import io.kubeblocks.apps.models.V1alpha1ComponentDefinitionSpecRolesInner;
import io.kubeblocks.apps.models.V1alpha1ComponentDefinitionSpecSystemAccountsInner;
import io.kubeblocks.apps.models.V1alpha1ComponentDefinitionSpecVarsInner;
import io.kubeblocks.apps.models.V1alpha1ComponentDefinitionSpecVolumesInner;
import io.kubeblocks.apps.models.V1alpha1ComponentSpecServicesInner;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * V1alpha1ComponentDefinitionSpec
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-06-13T15:59:08.817252Z[Etc/UTC]")
public class V1alpha1ComponentDefinitionSpec {
  public static final String SERIALIZED_NAME_ANNOTATIONS = "annotations";
  @SerializedName(SERIALIZED_NAME_ANNOTATIONS)
  private Map<String, String> annotations = new HashMap<>();

  public static final String SERIALIZED_NAME_CONFIGS = "configs";
  @SerializedName(SERIALIZED_NAME_CONFIGS)
  private List<V1alpha1ClusterDefinitionSpecComponentDefsInnerConfigSpecsInner> configs;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_EXPORTER = "exporter";
  @SerializedName(SERIALIZED_NAME_EXPORTER)
  private V1alpha1ComponentDefinitionSpecExporter exporter;

  public static final String SERIALIZED_NAME_HOST_NETWORK = "hostNetwork";
  @SerializedName(SERIALIZED_NAME_HOST_NETWORK)
  private V1alpha1ComponentDefinitionSpecHostNetwork hostNetwork;

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_LIFECYCLE_ACTIONS = "lifecycleActions";
  @SerializedName(SERIALIZED_NAME_LIFECYCLE_ACTIONS)
  private V1alpha1ComponentDefinitionSpecLifecycleActions lifecycleActions;

  public static final String SERIALIZED_NAME_LOG_CONFIGS = "logConfigs";
  @SerializedName(SERIALIZED_NAME_LOG_CONFIGS)
  private List<V1alpha1ClusterDefinitionSpecComponentDefsInnerLogConfigsInner> logConfigs;

  public static final String SERIALIZED_NAME_MIN_READY_SECONDS = "minReadySeconds";
  @SerializedName(SERIALIZED_NAME_MIN_READY_SECONDS)
  private Integer minReadySeconds;

  public static final String SERIALIZED_NAME_MONITOR = "monitor";
  @SerializedName(SERIALIZED_NAME_MONITOR)
  private V1alpha1ClusterDefinitionSpecComponentDefsInnerMonitor monitor;

  public static final String SERIALIZED_NAME_POLICY_RULES = "policyRules";
  @SerializedName(SERIALIZED_NAME_POLICY_RULES)
  private List<V1alpha1ComponentDefinitionSpecPolicyRulesInner> policyRules;

  public static final String SERIALIZED_NAME_PROVIDER = "provider";
  @SerializedName(SERIALIZED_NAME_PROVIDER)
  private String provider;

  public static final String SERIALIZED_NAME_REPLICAS_LIMIT = "replicasLimit";
  @SerializedName(SERIALIZED_NAME_REPLICAS_LIMIT)
  private V1alpha1ComponentDefinitionSpecReplicasLimit replicasLimit;

  /**
   * This field has been deprecated since v0.9. This field is maintained for backward compatibility and its use is discouraged. Existing usage should be updated to the current preferred approach to avoid compatibility issues in future releases.   This field is immutable.
   */
  @JsonAdapter(RoleArbitratorEnum.Adapter.class)
  public enum RoleArbitratorEnum {
    EXTERNAL("External"),
    
    LORRY("Lorry");

    private String value;

    RoleArbitratorEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static RoleArbitratorEnum fromValue(String value) {
      for (RoleArbitratorEnum b : RoleArbitratorEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<RoleArbitratorEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RoleArbitratorEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RoleArbitratorEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return RoleArbitratorEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_ROLE_ARBITRATOR = "roleArbitrator";
  @SerializedName(SERIALIZED_NAME_ROLE_ARBITRATOR)
  private RoleArbitratorEnum roleArbitrator;

  public static final String SERIALIZED_NAME_ROLES = "roles";
  @SerializedName(SERIALIZED_NAME_ROLES)
  private List<V1alpha1ComponentDefinitionSpecRolesInner> roles;

  public static final String SERIALIZED_NAME_RUNTIME = "runtime";
  @SerializedName(SERIALIZED_NAME_RUNTIME)
  private Object runtime;

  public static final String SERIALIZED_NAME_SCRIPTS = "scripts";
  @SerializedName(SERIALIZED_NAME_SCRIPTS)
  private List<V1alpha1ClusterDefinitionSpecComponentDefsInnerScriptSpecsInner> scripts;

  public static final String SERIALIZED_NAME_SERVICE_KIND = "serviceKind";
  @SerializedName(SERIALIZED_NAME_SERVICE_KIND)
  private String serviceKind;

  public static final String SERIALIZED_NAME_SERVICE_REF_DECLARATIONS = "serviceRefDeclarations";
  @SerializedName(SERIALIZED_NAME_SERVICE_REF_DECLARATIONS)
  private List<V1alpha1ClusterDefinitionSpecComponentDefsInnerServiceRefDeclarationsInner> serviceRefDeclarations;

  public static final String SERIALIZED_NAME_SERVICE_VERSION = "serviceVersion";
  @SerializedName(SERIALIZED_NAME_SERVICE_VERSION)
  private String serviceVersion;

  public static final String SERIALIZED_NAME_SERVICES = "services";
  @SerializedName(SERIALIZED_NAME_SERVICES)
  private List<V1alpha1ComponentSpecServicesInner> services;

  public static final String SERIALIZED_NAME_SYSTEM_ACCOUNTS = "systemAccounts";
  @SerializedName(SERIALIZED_NAME_SYSTEM_ACCOUNTS)
  private List<V1alpha1ComponentDefinitionSpecSystemAccountsInner> systemAccounts;

  /**
   * Specifies the concurrency strategy for updating multiple instances of the Component. Available strategies:   - &#x60;Serial&#x60;: Updates replicas one at a time, ensuring minimal downtime by waiting for each replica to become ready before updating the next. - &#x60;Parallel&#x60;: Updates all replicas simultaneously, optimizing for speed but potentially reducing availability during the update. - &#x60;BestEffortParallel&#x60;: Updates replicas concurrently with a limit on simultaneous updates to ensure a minimum number of operational replicas for maintaining quorum. For example, in a 5-replica component, updating a maximum of 2 replicas simultaneously keeps at least 3 operational for quorum.   This field is immutable and defaults to &#39;Serial&#39;.
   */
  @JsonAdapter(UpdateStrategyEnum.Adapter.class)
  public enum UpdateStrategyEnum {
    SERIAL("Serial"),
    
    BESTEFFORTPARALLEL("BestEffortParallel"),
    
    PARALLEL("Parallel");

    private String value;

    UpdateStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static UpdateStrategyEnum fromValue(String value) {
      for (UpdateStrategyEnum b : UpdateStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<UpdateStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final UpdateStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public UpdateStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return UpdateStrategyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_UPDATE_STRATEGY = "updateStrategy";
  @SerializedName(SERIALIZED_NAME_UPDATE_STRATEGY)
  private UpdateStrategyEnum updateStrategy;

  public static final String SERIALIZED_NAME_VARS = "vars";
  @SerializedName(SERIALIZED_NAME_VARS)
  private List<V1alpha1ComponentDefinitionSpecVarsInner> vars;

  public static final String SERIALIZED_NAME_VOLUMES = "volumes";
  @SerializedName(SERIALIZED_NAME_VOLUMES)
  private List<V1alpha1ComponentDefinitionSpecVolumesInner> volumes;

  public V1alpha1ComponentDefinitionSpec() {
  }

  public V1alpha1ComponentDefinitionSpec annotations(Map<String, String> annotations) {
    
    this.annotations = annotations;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec putAnnotationsItem(String key, String annotationsItem) {
    if (this.annotations == null) {
      this.annotations = new HashMap<>();
    }
    this.annotations.put(key, annotationsItem);
    return this;
  }

   /**
   * Specifies static annotations that will be patched to all Kubernetes resources created for the Component.   Note: If an annotation key in the &#x60;annotations&#x60; field conflicts with any system annotations or user-specified annotations, it will be silently ignored to avoid overriding higher-priority annotations.   This field is immutable.
   * @return annotations
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getAnnotations() {
    return annotations;
  }


  public void setAnnotations(Map<String, String> annotations) {
    this.annotations = annotations;
  }


  public V1alpha1ComponentDefinitionSpec configs(List<V1alpha1ClusterDefinitionSpecComponentDefsInnerConfigSpecsInner> configs) {
    
    this.configs = configs;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec addConfigsItem(V1alpha1ClusterDefinitionSpecComponentDefsInnerConfigSpecsInner configsItem) {
    if (this.configs == null) {
      this.configs = new ArrayList<>();
    }
    this.configs.add(configsItem);
    return this;
  }

   /**
   * Specifies the configuration file templates and volume mount parameters used by the Component. It also includes descriptions of the parameters in the ConfigMaps, such as value range limitations.   This field specifies a list of templates that will be rendered into Component containers&#39; configuration files. Each template is represented as a ConfigMap and may contain multiple configuration files, with each file being a key in the ConfigMap.   The rendered configuration files will be mounted into the Component&#39;s containers according to the specified volume mount parameters.   This field is immutable.   TODO: support referencing configs from other components or clusters.
   * @return configs
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ClusterDefinitionSpecComponentDefsInnerConfigSpecsInner> getConfigs() {
    return configs;
  }


  public void setConfigs(List<V1alpha1ClusterDefinitionSpecComponentDefsInnerConfigSpecsInner> configs) {
    this.configs = configs;
  }


  public V1alpha1ComponentDefinitionSpec description(String description) {
    
    this.description = description;
    return this;
  }

   /**
   * Provides a brief and concise explanation of the Component&#39;s purpose, functionality, and any relevant details. It serves as a quick reference for users to understand the Component&#39;s role and characteristics.
   * @return description
  **/
  @jakarta.annotation.Nullable
  public String getDescription() {
    return description;
  }


  public void setDescription(String description) {
    this.description = description;
  }


  public V1alpha1ComponentDefinitionSpec exporter(V1alpha1ComponentDefinitionSpecExporter exporter) {
    
    this.exporter = exporter;
    return this;
  }

   /**
   * Get exporter
   * @return exporter
  **/
  @jakarta.annotation.Nullable
  public V1alpha1ComponentDefinitionSpecExporter getExporter() {
    return exporter;
  }


  public void setExporter(V1alpha1ComponentDefinitionSpecExporter exporter) {
    this.exporter = exporter;
  }


  public V1alpha1ComponentDefinitionSpec hostNetwork(V1alpha1ComponentDefinitionSpecHostNetwork hostNetwork) {
    
    this.hostNetwork = hostNetwork;
    return this;
  }

   /**
   * Get hostNetwork
   * @return hostNetwork
  **/
  @jakarta.annotation.Nullable
  public V1alpha1ComponentDefinitionSpecHostNetwork getHostNetwork() {
    return hostNetwork;
  }


  public void setHostNetwork(V1alpha1ComponentDefinitionSpecHostNetwork hostNetwork) {
    this.hostNetwork = hostNetwork;
  }


  public V1alpha1ComponentDefinitionSpec labels(Map<String, String> labels) {
    
    this.labels = labels;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

   /**
   * Specifies static labels that will be patched to all Kubernetes resources created for the Component.   Note: If a label key in the &#x60;labels&#x60; field conflicts with any system labels or user-specified labels, it will be silently ignored to avoid overriding higher-priority labels.   This field is immutable.
   * @return labels
  **/
  @jakarta.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }


  public void setLabels(Map<String, String> labels) {
    this.labels = labels;
  }


  public V1alpha1ComponentDefinitionSpec lifecycleActions(V1alpha1ComponentDefinitionSpecLifecycleActions lifecycleActions) {
    
    this.lifecycleActions = lifecycleActions;
    return this;
  }

   /**
   * Get lifecycleActions
   * @return lifecycleActions
  **/
  @jakarta.annotation.Nullable
  public V1alpha1ComponentDefinitionSpecLifecycleActions getLifecycleActions() {
    return lifecycleActions;
  }


  public void setLifecycleActions(V1alpha1ComponentDefinitionSpecLifecycleActions lifecycleActions) {
    this.lifecycleActions = lifecycleActions;
  }


  public V1alpha1ComponentDefinitionSpec logConfigs(List<V1alpha1ClusterDefinitionSpecComponentDefsInnerLogConfigsInner> logConfigs) {
    
    this.logConfigs = logConfigs;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec addLogConfigsItem(V1alpha1ClusterDefinitionSpecComponentDefsInnerLogConfigsInner logConfigsItem) {
    if (this.logConfigs == null) {
      this.logConfigs = new ArrayList<>();
    }
    this.logConfigs.add(logConfigsItem);
    return this;
  }

   /**
   * Defines the types of logs generated by instances of the Component and their corresponding file paths. These logs can be collected for further analysis and monitoring.   The &#x60;logConfigs&#x60; field is an optional list of LogConfig objects, where each object represents a specific log type and its configuration. It allows you to specify multiple log types and their respective file paths for the Component.   Examples:   &#x60;&#x60;&#x60;yaml logConfigs: - filePathPattern: /data/mysql/log/mysqld-error.log name: error - filePathPattern: /data/mysql/log/mysqld.log name: general - filePathPattern: /data/mysql/log/mysqld-slowquery.log name: slow &#x60;&#x60;&#x60;   This field is immutable.
   * @return logConfigs
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ClusterDefinitionSpecComponentDefsInnerLogConfigsInner> getLogConfigs() {
    return logConfigs;
  }


  public void setLogConfigs(List<V1alpha1ClusterDefinitionSpecComponentDefsInnerLogConfigsInner> logConfigs) {
    this.logConfigs = logConfigs;
  }


  public V1alpha1ComponentDefinitionSpec minReadySeconds(Integer minReadySeconds) {
    
    this.minReadySeconds = minReadySeconds;
    return this;
  }

   /**
   * &#x60;minReadySeconds&#x60; is the minimum duration in seconds that a new Pod should remain in the ready state without any of its containers crashing to be considered available. This ensures the Pod&#39;s stability and readiness to serve requests.   A default value of 0 seconds means the Pod is considered available as soon as it enters the ready state.
   * minimum: 0
   * @return minReadySeconds
  **/
  @jakarta.annotation.Nullable
  public Integer getMinReadySeconds() {
    return minReadySeconds;
  }


  public void setMinReadySeconds(Integer minReadySeconds) {
    this.minReadySeconds = minReadySeconds;
  }


  public V1alpha1ComponentDefinitionSpec monitor(V1alpha1ClusterDefinitionSpecComponentDefsInnerMonitor monitor) {
    
    this.monitor = monitor;
    return this;
  }

   /**
   * Get monitor
   * @return monitor
  **/
  @jakarta.annotation.Nullable
  public V1alpha1ClusterDefinitionSpecComponentDefsInnerMonitor getMonitor() {
    return monitor;
  }


  public void setMonitor(V1alpha1ClusterDefinitionSpecComponentDefsInnerMonitor monitor) {
    this.monitor = monitor;
  }


  public V1alpha1ComponentDefinitionSpec policyRules(List<V1alpha1ComponentDefinitionSpecPolicyRulesInner> policyRules) {
    
    this.policyRules = policyRules;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec addPolicyRulesItem(V1alpha1ComponentDefinitionSpecPolicyRulesInner policyRulesItem) {
    if (this.policyRules == null) {
      this.policyRules = new ArrayList<>();
    }
    this.policyRules.add(policyRulesItem);
    return this;
  }

   /**
   * Defines the namespaced policy rules required by the Component.   The &#x60;policyRules&#x60; field is an array of &#x60;rbacv1.PolicyRule&#x60; objects that define the policy rules needed by the Component to operate within a namespace. These policy rules determine the permissions and verbs the Component is allowed to perform on Kubernetes resources within the namespace.   The purpose of this field is to automatically generate the necessary RBAC roles for the Component based on the specified policy rules. This ensures that the Pods in the Component has appropriate permissions to function.   Note: This field is currently non-functional and is reserved for future implementation.   This field is immutable.
   * @return policyRules
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ComponentDefinitionSpecPolicyRulesInner> getPolicyRules() {
    return policyRules;
  }


  public void setPolicyRules(List<V1alpha1ComponentDefinitionSpecPolicyRulesInner> policyRules) {
    this.policyRules = policyRules;
  }


  public V1alpha1ComponentDefinitionSpec provider(String provider) {
    
    this.provider = provider;
    return this;
  }

   /**
   * Specifies the name of the Component provider, typically the vendor or developer name. It identifies the entity responsible for creating and maintaining the Component.   When specifying the provider name, consider the following guidelines:   - Keep the name concise and relevant to the Component. - Use a consistent naming convention across Components from the same provider. - Avoid using trademarked or copyrighted names without proper permission.
   * @return provider
  **/
  @jakarta.annotation.Nullable
  public String getProvider() {
    return provider;
  }


  public void setProvider(String provider) {
    this.provider = provider;
  }


  public V1alpha1ComponentDefinitionSpec replicasLimit(V1alpha1ComponentDefinitionSpecReplicasLimit replicasLimit) {
    
    this.replicasLimit = replicasLimit;
    return this;
  }

   /**
   * Get replicasLimit
   * @return replicasLimit
  **/
  @jakarta.annotation.Nullable
  public V1alpha1ComponentDefinitionSpecReplicasLimit getReplicasLimit() {
    return replicasLimit;
  }


  public void setReplicasLimit(V1alpha1ComponentDefinitionSpecReplicasLimit replicasLimit) {
    this.replicasLimit = replicasLimit;
  }


  public V1alpha1ComponentDefinitionSpec roleArbitrator(RoleArbitratorEnum roleArbitrator) {
    
    this.roleArbitrator = roleArbitrator;
    return this;
  }

   /**
   * This field has been deprecated since v0.9. This field is maintained for backward compatibility and its use is discouraged. Existing usage should be updated to the current preferred approach to avoid compatibility issues in future releases.   This field is immutable.
   * @return roleArbitrator
  **/
  @jakarta.annotation.Nullable
  public RoleArbitratorEnum getRoleArbitrator() {
    return roleArbitrator;
  }


  public void setRoleArbitrator(RoleArbitratorEnum roleArbitrator) {
    this.roleArbitrator = roleArbitrator;
  }


  public V1alpha1ComponentDefinitionSpec roles(List<V1alpha1ComponentDefinitionSpecRolesInner> roles) {
    
    this.roles = roles;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec addRolesItem(V1alpha1ComponentDefinitionSpecRolesInner rolesItem) {
    if (this.roles == null) {
      this.roles = new ArrayList<>();
    }
    this.roles.add(rolesItem);
    return this;
  }

   /**
   * Enumerate all possible roles assigned to each replica of the Component, influencing its behavior.   A replica can have zero to multiple roles. KubeBlocks operator determines the roles of each replica by invoking the &#x60;lifecycleActions.roleProbe&#x60; method. This action returns a list of roles for each replica, and the returned roles must be predefined in the &#x60;roles&#x60; field.   The roles assigned to a replica can influence various aspects of the Component&#39;s behavior, such as:   - Service selection: The Component&#39;s exposed Services may target replicas based on their roles using &#x60;roleSelector&#x60;. - Update order: The roles can determine the order in which replicas are updated during a Component update. For instance, replicas with a \&quot;follower\&quot; role can be updated first, while the replica with the \&quot;leader\&quot; role is updated last. This helps minimize the number of leader changes during the update process.   This field is immutable.
   * @return roles
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ComponentDefinitionSpecRolesInner> getRoles() {
    return roles;
  }


  public void setRoles(List<V1alpha1ComponentDefinitionSpecRolesInner> roles) {
    this.roles = roles;
  }


  public V1alpha1ComponentDefinitionSpec runtime(Object runtime) {
    
    this.runtime = runtime;
    return this;
  }

   /**
   * Specifies the PodSpec template used in the Component. It includes the following elements:   - Init containers - Containers - Image - Commands - Args - Envs - Mounts - Ports - Security context - Probes - Lifecycle - Volumes   This field is intended to define static settings that remain consistent across all instantiated Components. Dynamic settings such as CPU and memory resource limits, as well as scheduling settings (affinity, toleration, priority), may vary among different instantiated Components. They should be specified in the &#x60;cluster.spec.componentSpecs&#x60; (ClusterComponentSpec).   Specific instances of a Component may override settings defined here, such as using a different container image or modifying environment variable values. These instance-specific overrides can be specified in &#x60;cluster.spec.componentSpecs[*].instances&#x60;.   This field is immutable and cannot be updated once set.
   * @return runtime
  **/
  @jakarta.annotation.Nonnull
  public Object getRuntime() {
    return runtime;
  }


  public void setRuntime(Object runtime) {
    this.runtime = runtime;
  }


  public V1alpha1ComponentDefinitionSpec scripts(List<V1alpha1ClusterDefinitionSpecComponentDefsInnerScriptSpecsInner> scripts) {
    
    this.scripts = scripts;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec addScriptsItem(V1alpha1ClusterDefinitionSpecComponentDefsInnerScriptSpecsInner scriptsItem) {
    if (this.scripts == null) {
      this.scripts = new ArrayList<>();
    }
    this.scripts.add(scriptsItem);
    return this;
  }

   /**
   * Specifies groups of scripts, each provided via a ConfigMap, to be mounted as volumes in the container. These scripts can be executed during container startup or via specific actions.   Each script group is encapsulated in a ComponentTemplateSpec that includes:   - The ConfigMap containing the scripts. - The mount point where the scripts will be mounted inside the container.   This field is immutable.
   * @return scripts
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ClusterDefinitionSpecComponentDefsInnerScriptSpecsInner> getScripts() {
    return scripts;
  }


  public void setScripts(List<V1alpha1ClusterDefinitionSpecComponentDefsInnerScriptSpecsInner> scripts) {
    this.scripts = scripts;
  }


  public V1alpha1ComponentDefinitionSpec serviceKind(String serviceKind) {
    
    this.serviceKind = serviceKind;
    return this;
  }

   /**
   * Defines the type of well-known service protocol that the Component provides. It specifies the standard or widely recognized protocol used by the Component to offer its Services.   The &#x60;serviceKind&#x60; field allows users to quickly identify the type of Service provided by the Component based on common protocols or service types. This information helps in understanding the compatibility, interoperability, and usage of the Component within a system.   Some examples of well-known service protocols include:   - \&quot;MySQL\&quot;: Indicates that the Component provides a MySQL database service. - \&quot;PostgreSQL\&quot;: Indicates that the Component offers a PostgreSQL database service. - \&quot;Redis\&quot;: Signifies that the Component functions as a Redis key-value store. - \&quot;ETCD\&quot;: Denotes that the Component serves as an ETCD distributed key-value store.   The &#x60;serviceKind&#x60; value is case-insensitive, allowing for flexibility in specifying the protocol name.   When specifying the &#x60;serviceKind&#x60;, consider the following guidelines:   - Use well-established and widely recognized protocol names or service types. - Ensure that the &#x60;serviceKind&#x60; accurately represents the primary service type offered by the Component. - If the Component provides multiple services, choose the most prominent or commonly used protocol. - Limit the &#x60;serviceKind&#x60; to a maximum of 32 characters for conciseness and readability.   Note: The &#x60;serviceKind&#x60; field is optional and can be left empty if the Component does not fit into a well-known service category or if the protocol is not widely recognized. It is primarily used to convey information about the Component&#39;s service type to users and facilitate discovery and integration.   The &#x60;serviceKind&#x60; field is immutable and cannot be updated.
   * @return serviceKind
  **/
  @jakarta.annotation.Nullable
  public String getServiceKind() {
    return serviceKind;
  }


  public void setServiceKind(String serviceKind) {
    this.serviceKind = serviceKind;
  }


  public V1alpha1ComponentDefinitionSpec serviceRefDeclarations(List<V1alpha1ClusterDefinitionSpecComponentDefsInnerServiceRefDeclarationsInner> serviceRefDeclarations) {
    
    this.serviceRefDeclarations = serviceRefDeclarations;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec addServiceRefDeclarationsItem(V1alpha1ClusterDefinitionSpecComponentDefsInnerServiceRefDeclarationsInner serviceRefDeclarationsItem) {
    if (this.serviceRefDeclarations == null) {
      this.serviceRefDeclarations = new ArrayList<>();
    }
    this.serviceRefDeclarations.add(serviceRefDeclarationsItem);
    return this;
  }

   /**
   * Lists external service dependencies of the Component, including services from other Clusters or outside the K8s environment.   This field is immutable.
   * @return serviceRefDeclarations
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ClusterDefinitionSpecComponentDefsInnerServiceRefDeclarationsInner> getServiceRefDeclarations() {
    return serviceRefDeclarations;
  }


  public void setServiceRefDeclarations(List<V1alpha1ClusterDefinitionSpecComponentDefsInnerServiceRefDeclarationsInner> serviceRefDeclarations) {
    this.serviceRefDeclarations = serviceRefDeclarations;
  }


  public V1alpha1ComponentDefinitionSpec serviceVersion(String serviceVersion) {
    
    this.serviceVersion = serviceVersion;
    return this;
  }

   /**
   * Specifies the version of the Service provided by the Component. It follows the syntax and semantics of the \&quot;Semantic Versioning\&quot; specification (http://semver.org/).   The Semantic Versioning specification defines a version number format of X.Y.Z (MAJOR.MINOR.PATCH), where:   - X represents the major version and indicates incompatible API changes. - Y represents the minor version and indicates added functionality in a backward-compatible manner. - Z represents the patch version and indicates backward-compatible bug fixes.   Additional labels for pre-release and build metadata are available as extensions to the X.Y.Z format:   - Use pre-release labels (e.g., -alpha, -beta) for versions that are not yet stable or ready for production use. - Use build metadata (e.g., +build.1) for additional version information if needed.   Examples of valid ServiceVersion values:   - \&quot;1.0.0\&quot; - \&quot;2.3.1\&quot; - \&quot;3.0.0-alpha.1\&quot; - \&quot;4.5.2+build.1\&quot;   The &#x60;serviceVersion&#x60; field is immutable and cannot be updated.
   * @return serviceVersion
  **/
  @jakarta.annotation.Nullable
  public String getServiceVersion() {
    return serviceVersion;
  }


  public void setServiceVersion(String serviceVersion) {
    this.serviceVersion = serviceVersion;
  }


  public V1alpha1ComponentDefinitionSpec services(List<V1alpha1ComponentSpecServicesInner> services) {
    
    this.services = services;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec addServicesItem(V1alpha1ComponentSpecServicesInner servicesItem) {
    if (this.services == null) {
      this.services = new ArrayList<>();
    }
    this.services.add(servicesItem);
    return this;
  }

   /**
   * Defines additional Services to expose the Component&#39;s endpoints.   A default headless Service, named &#x60;{cluster.name}-{component.name}-headless&#x60;, is automatically created for internal Cluster communication.   This field enables customization of additional Services to expose the Component&#39;s endpoints to other Components within the same or different Clusters, and to external applications. Each Service entry in this list can include properties such as ports, type, and selectors.   - For intra-Cluster access, Components can reference Services using variables declared in &#x60;componentDefinition.spec.vars[*].valueFrom.serviceVarRef&#x60;. - For inter-Cluster access, reference Services use variables declared in &#x60;componentDefinition.spec.vars[*].valueFrom.serviceRefVarRef&#x60;, and bind Services at Cluster creation time with &#x60;clusterComponentSpec.ServiceRef[*].clusterServiceSelector&#x60;.   This field is immutable.
   * @return services
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ComponentSpecServicesInner> getServices() {
    return services;
  }


  public void setServices(List<V1alpha1ComponentSpecServicesInner> services) {
    this.services = services;
  }


  public V1alpha1ComponentDefinitionSpec systemAccounts(List<V1alpha1ComponentDefinitionSpecSystemAccountsInner> systemAccounts) {
    
    this.systemAccounts = systemAccounts;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec addSystemAccountsItem(V1alpha1ComponentDefinitionSpecSystemAccountsInner systemAccountsItem) {
    if (this.systemAccounts == null) {
      this.systemAccounts = new ArrayList<>();
    }
    this.systemAccounts.add(systemAccountsItem);
    return this;
  }

   /**
   * An array of &#x60;SystemAccount&#x60; objects that define the system accounts needed for the management operations of the Component.   Each &#x60;SystemAccount&#x60; includes:   - Account name. - The SQL statement template: Used to create the system account. - Password Source: Either generated based on certain rules or retrieved from a Secret.   Use cases for system accounts typically involve tasks like system initialization, backups, monitoring, health checks, replication, and other system-level operations.   System accounts are distinct from user accounts, although both are database accounts.   - **System Accounts**: Created during Cluster setup by the KubeBlocks operator, these accounts have higher privileges for system management and are fully managed through a declarative API by the operator. - **User Accounts**: Managed by users or administrator. User account permissions should follow the principle of least privilege, granting only the necessary access rights to complete their required tasks.   This field is immutable.
   * @return systemAccounts
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ComponentDefinitionSpecSystemAccountsInner> getSystemAccounts() {
    return systemAccounts;
  }


  public void setSystemAccounts(List<V1alpha1ComponentDefinitionSpecSystemAccountsInner> systemAccounts) {
    this.systemAccounts = systemAccounts;
  }


  public V1alpha1ComponentDefinitionSpec updateStrategy(UpdateStrategyEnum updateStrategy) {
    
    this.updateStrategy = updateStrategy;
    return this;
  }

   /**
   * Specifies the concurrency strategy for updating multiple instances of the Component. Available strategies:   - &#x60;Serial&#x60;: Updates replicas one at a time, ensuring minimal downtime by waiting for each replica to become ready before updating the next. - &#x60;Parallel&#x60;: Updates all replicas simultaneously, optimizing for speed but potentially reducing availability during the update. - &#x60;BestEffortParallel&#x60;: Updates replicas concurrently with a limit on simultaneous updates to ensure a minimum number of operational replicas for maintaining quorum. For example, in a 5-replica component, updating a maximum of 2 replicas simultaneously keeps at least 3 operational for quorum.   This field is immutable and defaults to &#39;Serial&#39;.
   * @return updateStrategy
  **/
  @jakarta.annotation.Nullable
  public UpdateStrategyEnum getUpdateStrategy() {
    return updateStrategy;
  }


  public void setUpdateStrategy(UpdateStrategyEnum updateStrategy) {
    this.updateStrategy = updateStrategy;
  }


  public V1alpha1ComponentDefinitionSpec vars(List<V1alpha1ComponentDefinitionSpecVarsInner> vars) {
    
    this.vars = vars;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec addVarsItem(V1alpha1ComponentDefinitionSpecVarsInner varsItem) {
    if (this.vars == null) {
      this.vars = new ArrayList<>();
    }
    this.vars.add(varsItem);
    return this;
  }

   /**
   * Defines variables which are determined after Cluster instantiation and reflect dynamic or runtime attributes of instantiated Clusters. These variables serve as placeholders for setting environment variables in Pods and Actions, or for rendering configuration and script templates before actual values are finalized.   These variables are placed in front of the environment variables declared in the Pod if used as environment variables.   Variable values can be sourced from:   - ConfigMap: Select and extract a value from a specific key within a ConfigMap. - Secret: Select and extract a value from a specific key within a Secret. - HostNetwork: Retrieves values (including ports) from host-network resources. - Service: Retrieves values (including address, port, NodePort) from a selected Service. Intended to obtain the address of a ComponentService within the same Cluster. - Credential: Retrieves account name and password from a SystemAccount variable. - ServiceRef: Retrieves address, port, account name and password from a selected ServiceRefDeclaration. Designed to obtain the address bound to a ServiceRef, such as a ClusterService or ComponentService of another cluster or an external service. - Component: Retrieves values from a selected Component, including replicas and instance name list.   This field is immutable.
   * @return vars
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ComponentDefinitionSpecVarsInner> getVars() {
    return vars;
  }


  public void setVars(List<V1alpha1ComponentDefinitionSpecVarsInner> vars) {
    this.vars = vars;
  }


  public V1alpha1ComponentDefinitionSpec volumes(List<V1alpha1ComponentDefinitionSpecVolumesInner> volumes) {
    
    this.volumes = volumes;
    return this;
  }

  public V1alpha1ComponentDefinitionSpec addVolumesItem(V1alpha1ComponentDefinitionSpecVolumesInner volumesItem) {
    if (this.volumes == null) {
      this.volumes = new ArrayList<>();
    }
    this.volumes.add(volumesItem);
    return this;
  }

   /**
   * Defines the volumes used by the Component and some static attributes of the volumes. After defining the volumes here, user can reference them in the &#x60;cluster.spec.componentSpecs[*].volumeClaimTemplates&#x60; field to configure dynamic properties such as volume capacity and storage class.   This field allows you to specify the following:   - Snapshot behavior: Determines whether a snapshot of the volume should be taken when performing a snapshot backup of the Component. - Disk high watermark: Sets the high watermark for the volume&#39;s disk usage. When the disk usage reaches the specified threshold, it triggers an alert or action.   By configuring these volume behaviors, you can control how the volumes are managed and monitored within the Component.   This field is immutable.
   * @return volumes
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ComponentDefinitionSpecVolumesInner> getVolumes() {
    return volumes;
  }


  public void setVolumes(List<V1alpha1ComponentDefinitionSpecVolumesInner> volumes) {
    this.volumes = volumes;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1ComponentDefinitionSpec v1alpha1ComponentDefinitionSpec = (V1alpha1ComponentDefinitionSpec) o;
    return Objects.equals(this.annotations, v1alpha1ComponentDefinitionSpec.annotations) &&
        Objects.equals(this.configs, v1alpha1ComponentDefinitionSpec.configs) &&
        Objects.equals(this.description, v1alpha1ComponentDefinitionSpec.description) &&
        Objects.equals(this.exporter, v1alpha1ComponentDefinitionSpec.exporter) &&
        Objects.equals(this.hostNetwork, v1alpha1ComponentDefinitionSpec.hostNetwork) &&
        Objects.equals(this.labels, v1alpha1ComponentDefinitionSpec.labels) &&
        Objects.equals(this.lifecycleActions, v1alpha1ComponentDefinitionSpec.lifecycleActions) &&
        Objects.equals(this.logConfigs, v1alpha1ComponentDefinitionSpec.logConfigs) &&
        Objects.equals(this.minReadySeconds, v1alpha1ComponentDefinitionSpec.minReadySeconds) &&
        Objects.equals(this.monitor, v1alpha1ComponentDefinitionSpec.monitor) &&
        Objects.equals(this.policyRules, v1alpha1ComponentDefinitionSpec.policyRules) &&
        Objects.equals(this.provider, v1alpha1ComponentDefinitionSpec.provider) &&
        Objects.equals(this.replicasLimit, v1alpha1ComponentDefinitionSpec.replicasLimit) &&
        Objects.equals(this.roleArbitrator, v1alpha1ComponentDefinitionSpec.roleArbitrator) &&
        Objects.equals(this.roles, v1alpha1ComponentDefinitionSpec.roles) &&
        Objects.equals(this.runtime, v1alpha1ComponentDefinitionSpec.runtime) &&
        Objects.equals(this.scripts, v1alpha1ComponentDefinitionSpec.scripts) &&
        Objects.equals(this.serviceKind, v1alpha1ComponentDefinitionSpec.serviceKind) &&
        Objects.equals(this.serviceRefDeclarations, v1alpha1ComponentDefinitionSpec.serviceRefDeclarations) &&
        Objects.equals(this.serviceVersion, v1alpha1ComponentDefinitionSpec.serviceVersion) &&
        Objects.equals(this.services, v1alpha1ComponentDefinitionSpec.services) &&
        Objects.equals(this.systemAccounts, v1alpha1ComponentDefinitionSpec.systemAccounts) &&
        Objects.equals(this.updateStrategy, v1alpha1ComponentDefinitionSpec.updateStrategy) &&
        Objects.equals(this.vars, v1alpha1ComponentDefinitionSpec.vars) &&
        Objects.equals(this.volumes, v1alpha1ComponentDefinitionSpec.volumes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotations, configs, description, exporter, hostNetwork, labels, lifecycleActions, logConfigs, minReadySeconds, monitor, policyRules, provider, replicasLimit, roleArbitrator, roles, runtime, scripts, serviceKind, serviceRefDeclarations, serviceVersion, services, systemAccounts, updateStrategy, vars, volumes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1ComponentDefinitionSpec {\n");
    sb.append("    annotations: ").append(toIndentedString(annotations)).append("\n");
    sb.append("    configs: ").append(toIndentedString(configs)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    exporter: ").append(toIndentedString(exporter)).append("\n");
    sb.append("    hostNetwork: ").append(toIndentedString(hostNetwork)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    lifecycleActions: ").append(toIndentedString(lifecycleActions)).append("\n");
    sb.append("    logConfigs: ").append(toIndentedString(logConfigs)).append("\n");
    sb.append("    minReadySeconds: ").append(toIndentedString(minReadySeconds)).append("\n");
    sb.append("    monitor: ").append(toIndentedString(monitor)).append("\n");
    sb.append("    policyRules: ").append(toIndentedString(policyRules)).append("\n");
    sb.append("    provider: ").append(toIndentedString(provider)).append("\n");
    sb.append("    replicasLimit: ").append(toIndentedString(replicasLimit)).append("\n");
    sb.append("    roleArbitrator: ").append(toIndentedString(roleArbitrator)).append("\n");
    sb.append("    roles: ").append(toIndentedString(roles)).append("\n");
    sb.append("    runtime: ").append(toIndentedString(runtime)).append("\n");
    sb.append("    scripts: ").append(toIndentedString(scripts)).append("\n");
    sb.append("    serviceKind: ").append(toIndentedString(serviceKind)).append("\n");
    sb.append("    serviceRefDeclarations: ").append(toIndentedString(serviceRefDeclarations)).append("\n");
    sb.append("    serviceVersion: ").append(toIndentedString(serviceVersion)).append("\n");
    sb.append("    services: ").append(toIndentedString(services)).append("\n");
    sb.append("    systemAccounts: ").append(toIndentedString(systemAccounts)).append("\n");
    sb.append("    updateStrategy: ").append(toIndentedString(updateStrategy)).append("\n");
    sb.append("    vars: ").append(toIndentedString(vars)).append("\n");
    sb.append("    volumes: ").append(toIndentedString(volumes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("annotations");
    openapiFields.add("configs");
    openapiFields.add("description");
    openapiFields.add("exporter");
    openapiFields.add("hostNetwork");
    openapiFields.add("labels");
    openapiFields.add("lifecycleActions");
    openapiFields.add("logConfigs");
    openapiFields.add("minReadySeconds");
    openapiFields.add("monitor");
    openapiFields.add("policyRules");
    openapiFields.add("provider");
    openapiFields.add("replicasLimit");
    openapiFields.add("roleArbitrator");
    openapiFields.add("roles");
    openapiFields.add("runtime");
    openapiFields.add("scripts");
    openapiFields.add("serviceKind");
    openapiFields.add("serviceRefDeclarations");
    openapiFields.add("serviceVersion");
    openapiFields.add("services");
    openapiFields.add("systemAccounts");
    openapiFields.add("updateStrategy");
    openapiFields.add("vars");
    openapiFields.add("volumes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("runtime");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1alpha1ComponentDefinitionSpec
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1alpha1ComponentDefinitionSpec.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1alpha1ComponentDefinitionSpec is not found in the empty JSON string", V1alpha1ComponentDefinitionSpec.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1alpha1ComponentDefinitionSpec.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1alpha1ComponentDefinitionSpec` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : V1alpha1ComponentDefinitionSpec.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      if (jsonObj.get("configs") != null && !jsonObj.get("configs").isJsonNull()) {
        JsonArray jsonArrayconfigs = jsonObj.getAsJsonArray("configs");
        if (jsonArrayconfigs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("configs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `configs` to be an array in the JSON string but got `%s`", jsonObj.get("configs").toString()));
          }

          // validate the optional field `configs` (array)
          for (int i = 0; i < jsonArrayconfigs.size(); i++) {
            V1alpha1ClusterDefinitionSpecComponentDefsInnerConfigSpecsInner.validateJsonObject(jsonArrayconfigs.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // validate the optional field `exporter`
      if (jsonObj.get("exporter") != null && !jsonObj.get("exporter").isJsonNull()) {
        V1alpha1ComponentDefinitionSpecExporter.validateJsonObject(jsonObj.getAsJsonObject("exporter"));
      }
      // validate the optional field `hostNetwork`
      if (jsonObj.get("hostNetwork") != null && !jsonObj.get("hostNetwork").isJsonNull()) {
        V1alpha1ComponentDefinitionSpecHostNetwork.validateJsonObject(jsonObj.getAsJsonObject("hostNetwork"));
      }
      // validate the optional field `lifecycleActions`
      if (jsonObj.get("lifecycleActions") != null && !jsonObj.get("lifecycleActions").isJsonNull()) {
        V1alpha1ComponentDefinitionSpecLifecycleActions.validateJsonObject(jsonObj.getAsJsonObject("lifecycleActions"));
      }
      if (jsonObj.get("logConfigs") != null && !jsonObj.get("logConfigs").isJsonNull()) {
        JsonArray jsonArraylogConfigs = jsonObj.getAsJsonArray("logConfigs");
        if (jsonArraylogConfigs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("logConfigs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `logConfigs` to be an array in the JSON string but got `%s`", jsonObj.get("logConfigs").toString()));
          }

          // validate the optional field `logConfigs` (array)
          for (int i = 0; i < jsonArraylogConfigs.size(); i++) {
            V1alpha1ClusterDefinitionSpecComponentDefsInnerLogConfigsInner.validateJsonObject(jsonArraylogConfigs.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `monitor`
      if (jsonObj.get("monitor") != null && !jsonObj.get("monitor").isJsonNull()) {
        V1alpha1ClusterDefinitionSpecComponentDefsInnerMonitor.validateJsonObject(jsonObj.getAsJsonObject("monitor"));
      }
      if (jsonObj.get("policyRules") != null && !jsonObj.get("policyRules").isJsonNull()) {
        JsonArray jsonArraypolicyRules = jsonObj.getAsJsonArray("policyRules");
        if (jsonArraypolicyRules != null) {
          // ensure the json data is an array
          if (!jsonObj.get("policyRules").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `policyRules` to be an array in the JSON string but got `%s`", jsonObj.get("policyRules").toString()));
          }

          // validate the optional field `policyRules` (array)
          for (int i = 0; i < jsonArraypolicyRules.size(); i++) {
            V1alpha1ComponentDefinitionSpecPolicyRulesInner.validateJsonObject(jsonArraypolicyRules.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("provider") != null && !jsonObj.get("provider").isJsonNull()) && !jsonObj.get("provider").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `provider` to be a primitive type in the JSON string but got `%s`", jsonObj.get("provider").toString()));
      }
      // validate the optional field `replicasLimit`
      if (jsonObj.get("replicasLimit") != null && !jsonObj.get("replicasLimit").isJsonNull()) {
        V1alpha1ComponentDefinitionSpecReplicasLimit.validateJsonObject(jsonObj.getAsJsonObject("replicasLimit"));
      }
      if ((jsonObj.get("roleArbitrator") != null && !jsonObj.get("roleArbitrator").isJsonNull()) && !jsonObj.get("roleArbitrator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `roleArbitrator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("roleArbitrator").toString()));
      }
      if (jsonObj.get("roles") != null && !jsonObj.get("roles").isJsonNull()) {
        JsonArray jsonArrayroles = jsonObj.getAsJsonArray("roles");
        if (jsonArrayroles != null) {
          // ensure the json data is an array
          if (!jsonObj.get("roles").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `roles` to be an array in the JSON string but got `%s`", jsonObj.get("roles").toString()));
          }

          // validate the optional field `roles` (array)
          for (int i = 0; i < jsonArrayroles.size(); i++) {
            V1alpha1ComponentDefinitionSpecRolesInner.validateJsonObject(jsonArrayroles.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("scripts") != null && !jsonObj.get("scripts").isJsonNull()) {
        JsonArray jsonArrayscripts = jsonObj.getAsJsonArray("scripts");
        if (jsonArrayscripts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("scripts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `scripts` to be an array in the JSON string but got `%s`", jsonObj.get("scripts").toString()));
          }

          // validate the optional field `scripts` (array)
          for (int i = 0; i < jsonArrayscripts.size(); i++) {
            V1alpha1ClusterDefinitionSpecComponentDefsInnerScriptSpecsInner.validateJsonObject(jsonArrayscripts.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("serviceKind") != null && !jsonObj.get("serviceKind").isJsonNull()) && !jsonObj.get("serviceKind").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceKind` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceKind").toString()));
      }
      if (jsonObj.get("serviceRefDeclarations") != null && !jsonObj.get("serviceRefDeclarations").isJsonNull()) {
        JsonArray jsonArrayserviceRefDeclarations = jsonObj.getAsJsonArray("serviceRefDeclarations");
        if (jsonArrayserviceRefDeclarations != null) {
          // ensure the json data is an array
          if (!jsonObj.get("serviceRefDeclarations").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `serviceRefDeclarations` to be an array in the JSON string but got `%s`", jsonObj.get("serviceRefDeclarations").toString()));
          }

          // validate the optional field `serviceRefDeclarations` (array)
          for (int i = 0; i < jsonArrayserviceRefDeclarations.size(); i++) {
            V1alpha1ClusterDefinitionSpecComponentDefsInnerServiceRefDeclarationsInner.validateJsonObject(jsonArrayserviceRefDeclarations.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("serviceVersion") != null && !jsonObj.get("serviceVersion").isJsonNull()) && !jsonObj.get("serviceVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceVersion").toString()));
      }
      if (jsonObj.get("services") != null && !jsonObj.get("services").isJsonNull()) {
        JsonArray jsonArrayservices = jsonObj.getAsJsonArray("services");
        if (jsonArrayservices != null) {
          // ensure the json data is an array
          if (!jsonObj.get("services").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `services` to be an array in the JSON string but got `%s`", jsonObj.get("services").toString()));
          }

          // validate the optional field `services` (array)
          for (int i = 0; i < jsonArrayservices.size(); i++) {
            V1alpha1ComponentSpecServicesInner.validateJsonObject(jsonArrayservices.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("systemAccounts") != null && !jsonObj.get("systemAccounts").isJsonNull()) {
        JsonArray jsonArraysystemAccounts = jsonObj.getAsJsonArray("systemAccounts");
        if (jsonArraysystemAccounts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("systemAccounts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `systemAccounts` to be an array in the JSON string but got `%s`", jsonObj.get("systemAccounts").toString()));
          }

          // validate the optional field `systemAccounts` (array)
          for (int i = 0; i < jsonArraysystemAccounts.size(); i++) {
            V1alpha1ComponentDefinitionSpecSystemAccountsInner.validateJsonObject(jsonArraysystemAccounts.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("updateStrategy") != null && !jsonObj.get("updateStrategy").isJsonNull()) && !jsonObj.get("updateStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateStrategy").toString()));
      }
      if (jsonObj.get("vars") != null && !jsonObj.get("vars").isJsonNull()) {
        JsonArray jsonArrayvars = jsonObj.getAsJsonArray("vars");
        if (jsonArrayvars != null) {
          // ensure the json data is an array
          if (!jsonObj.get("vars").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `vars` to be an array in the JSON string but got `%s`", jsonObj.get("vars").toString()));
          }

          // validate the optional field `vars` (array)
          for (int i = 0; i < jsonArrayvars.size(); i++) {
            V1alpha1ComponentDefinitionSpecVarsInner.validateJsonObject(jsonArrayvars.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("volumes") != null && !jsonObj.get("volumes").isJsonNull()) {
        JsonArray jsonArrayvolumes = jsonObj.getAsJsonArray("volumes");
        if (jsonArrayvolumes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("volumes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `volumes` to be an array in the JSON string but got `%s`", jsonObj.get("volumes").toString()));
          }

          // validate the optional field `volumes` (array)
          for (int i = 0; i < jsonArrayvolumes.size(); i++) {
            V1alpha1ComponentDefinitionSpecVolumesInner.validateJsonObject(jsonArrayvolumes.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1alpha1ComponentDefinitionSpec.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1alpha1ComponentDefinitionSpec' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1alpha1ComponentDefinitionSpec> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1alpha1ComponentDefinitionSpec.class));

       return (TypeAdapter<T>) new TypeAdapter<V1alpha1ComponentDefinitionSpec>() {
           @Override
           public void write(JsonWriter out, V1alpha1ComponentDefinitionSpec value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1alpha1ComponentDefinitionSpec read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1alpha1ComponentDefinitionSpec given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1alpha1ComponentDefinitionSpec
  * @throws IOException if the JSON string is invalid with respect to V1alpha1ComponentDefinitionSpec
  */
  public static V1alpha1ComponentDefinitionSpec fromJson(String jsonString) throws IOException {
    return new JSON().getGson().fromJson(jsonString, V1alpha1ComponentDefinitionSpec.class);
  }

 /**
  * Convert an instance of V1alpha1ComponentDefinitionSpec to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return new JSON().getGson().toJson(this);
  }
}

