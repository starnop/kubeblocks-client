/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.27.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.kubeblocks.apps.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecsInnerAffinity;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecsInnerClassDefRef;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecsInnerInstancesInner;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecsInnerInstancesInnerVolumeClaimTemplatesInner;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecsInnerIssuer;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecsInnerServiceRefsInner;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecsInnerServicesInner;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecsInnerSwitchPolicy;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecsInnerSystemAccountsInner;
import io.kubeblocks.apps.models.V1alpha1ClusterSpecComponentSpecsInnerUserResourceRefs;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * ClusterComponentSpec defines the specification of a Component within a Cluster. TODO +kubebuilder:validation:XValidation:rule&#x3D;\&quot;!has(oldSelf.componentDefRef) || has(self.componentDefRef)\&quot;, message&#x3D;\&quot;componentDefRef is required once set\&quot; TODO +kubebuilder:validation:XValidation:rule&#x3D;\&quot;!has(oldSelf.componentDef) || has(self.componentDef)\&quot;, message&#x3D;\&quot;componentDef is required once set\&quot;
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-06-13T15:59:08.817252Z[Etc/UTC]")
public class V1alpha1ClusterSpecComponentSpecsInner {
  public static final String SERIALIZED_NAME_AFFINITY = "affinity";
  @SerializedName(SERIALIZED_NAME_AFFINITY)
  private V1alpha1ClusterSpecComponentSpecsInnerAffinity affinity;

  public static final String SERIALIZED_NAME_CLASS_DEF_REF = "classDefRef";
  @SerializedName(SERIALIZED_NAME_CLASS_DEF_REF)
  private V1alpha1ClusterSpecComponentSpecsInnerClassDefRef classDefRef;

  public static final String SERIALIZED_NAME_COMPONENT_DEF = "componentDef";
  @SerializedName(SERIALIZED_NAME_COMPONENT_DEF)
  private String componentDef;

  public static final String SERIALIZED_NAME_COMPONENT_DEF_REF = "componentDefRef";
  @SerializedName(SERIALIZED_NAME_COMPONENT_DEF_REF)
  private String componentDefRef;

  public static final String SERIALIZED_NAME_DISABLE_EXPORTER = "disableExporter";
  @SerializedName(SERIALIZED_NAME_DISABLE_EXPORTER)
  private Boolean disableExporter;

  public static final String SERIALIZED_NAME_ENABLED_LOGS = "enabledLogs";
  @SerializedName(SERIALIZED_NAME_ENABLED_LOGS)
  private List<String> enabledLogs;

  public static final String SERIALIZED_NAME_INSTANCES = "instances";
  @SerializedName(SERIALIZED_NAME_INSTANCES)
  private List<V1alpha1ClusterSpecComponentSpecsInnerInstancesInner> instances;

  public static final String SERIALIZED_NAME_ISSUER = "issuer";
  @SerializedName(SERIALIZED_NAME_ISSUER)
  private V1alpha1ClusterSpecComponentSpecsInnerIssuer issuer;

  public static final String SERIALIZED_NAME_MONITOR = "monitor";
  @SerializedName(SERIALIZED_NAME_MONITOR)
  private Boolean monitor;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_OFFLINE_INSTANCES = "offlineInstances";
  @SerializedName(SERIALIZED_NAME_OFFLINE_INSTANCES)
  private List<String> offlineInstances;

  public static final String SERIALIZED_NAME_REPLICAS = "replicas";
  @SerializedName(SERIALIZED_NAME_REPLICAS)
  private Integer replicas;

  public static final String SERIALIZED_NAME_RESOURCES = "resources";
  @SerializedName(SERIALIZED_NAME_RESOURCES)
  private Object resources;

  public static final String SERIALIZED_NAME_SERVICE_ACCOUNT_NAME = "serviceAccountName";
  @SerializedName(SERIALIZED_NAME_SERVICE_ACCOUNT_NAME)
  private String serviceAccountName;

  public static final String SERIALIZED_NAME_SERVICE_REFS = "serviceRefs";
  @SerializedName(SERIALIZED_NAME_SERVICE_REFS)
  private List<V1alpha1ClusterSpecComponentSpecsInnerServiceRefsInner> serviceRefs;

  public static final String SERIALIZED_NAME_SERVICE_VERSION = "serviceVersion";
  @SerializedName(SERIALIZED_NAME_SERVICE_VERSION)
  private String serviceVersion;

  public static final String SERIALIZED_NAME_SERVICES = "services";
  @SerializedName(SERIALIZED_NAME_SERVICES)
  private List<V1alpha1ClusterSpecComponentSpecsInnerServicesInner> services;

  public static final String SERIALIZED_NAME_SWITCH_POLICY = "switchPolicy";
  @SerializedName(SERIALIZED_NAME_SWITCH_POLICY)
  private V1alpha1ClusterSpecComponentSpecsInnerSwitchPolicy switchPolicy;

  public static final String SERIALIZED_NAME_SYSTEM_ACCOUNTS = "systemAccounts";
  @SerializedName(SERIALIZED_NAME_SYSTEM_ACCOUNTS)
  private List<V1alpha1ClusterSpecComponentSpecsInnerSystemAccountsInner> systemAccounts;

  public static final String SERIALIZED_NAME_TLS = "tls";
  @SerializedName(SERIALIZED_NAME_TLS)
  private Boolean tls;

  public static final String SERIALIZED_NAME_TOLERATIONS = "tolerations";
  @SerializedName(SERIALIZED_NAME_TOLERATIONS)
  private Object tolerations;

  /**
   * Defines the update strategy for the Component.   Deprecated since v0.9. This field is maintained for backward compatibility and its use is discouraged. Existing usage should be updated to the current preferred approach to avoid compatibility issues in future releases.
   */
  @JsonAdapter(UpdateStrategyEnum.Adapter.class)
  public enum UpdateStrategyEnum {
    SERIAL("Serial"),
    
    BESTEFFORTPARALLEL("BestEffortParallel"),
    
    PARALLEL("Parallel");

    private String value;

    UpdateStrategyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static UpdateStrategyEnum fromValue(String value) {
      for (UpdateStrategyEnum b : UpdateStrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<UpdateStrategyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final UpdateStrategyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public UpdateStrategyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return UpdateStrategyEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_UPDATE_STRATEGY = "updateStrategy";
  @SerializedName(SERIALIZED_NAME_UPDATE_STRATEGY)
  private UpdateStrategyEnum updateStrategy;

  public static final String SERIALIZED_NAME_USER_RESOURCE_REFS = "userResourceRefs";
  @SerializedName(SERIALIZED_NAME_USER_RESOURCE_REFS)
  private V1alpha1ClusterSpecComponentSpecsInnerUserResourceRefs userResourceRefs;

  public static final String SERIALIZED_NAME_VOLUME_CLAIM_TEMPLATES = "volumeClaimTemplates";
  @SerializedName(SERIALIZED_NAME_VOLUME_CLAIM_TEMPLATES)
  private List<V1alpha1ClusterSpecComponentSpecsInnerInstancesInnerVolumeClaimTemplatesInner> volumeClaimTemplates;

  public V1alpha1ClusterSpecComponentSpecsInner() {
  }

  public V1alpha1ClusterSpecComponentSpecsInner affinity(V1alpha1ClusterSpecComponentSpecsInnerAffinity affinity) {
    
    this.affinity = affinity;
    return this;
  }

   /**
   * Get affinity
   * @return affinity
  **/
  @jakarta.annotation.Nullable
  public V1alpha1ClusterSpecComponentSpecsInnerAffinity getAffinity() {
    return affinity;
  }


  public void setAffinity(V1alpha1ClusterSpecComponentSpecsInnerAffinity affinity) {
    this.affinity = affinity;
  }


  public V1alpha1ClusterSpecComponentSpecsInner classDefRef(V1alpha1ClusterSpecComponentSpecsInnerClassDefRef classDefRef) {
    
    this.classDefRef = classDefRef;
    return this;
  }

   /**
   * Get classDefRef
   * @return classDefRef
  **/
  @jakarta.annotation.Nullable
  public V1alpha1ClusterSpecComponentSpecsInnerClassDefRef getClassDefRef() {
    return classDefRef;
  }


  public void setClassDefRef(V1alpha1ClusterSpecComponentSpecsInnerClassDefRef classDefRef) {
    this.classDefRef = classDefRef;
  }


  public V1alpha1ClusterSpecComponentSpecsInner componentDef(String componentDef) {
    
    this.componentDef = componentDef;
    return this;
  }

   /**
   * References the name of a ComponentDefinition object. The ComponentDefinition specifies the behavior and characteristics of the Component. If both &#x60;componentDefRef&#x60; and &#x60;componentDef&#x60; are provided, the &#x60;componentDef&#x60; will take precedence over &#x60;componentDefRef&#x60;.
   * @return componentDef
  **/
  @jakarta.annotation.Nullable
  public String getComponentDef() {
    return componentDef;
  }


  public void setComponentDef(String componentDef) {
    this.componentDef = componentDef;
  }


  public V1alpha1ClusterSpecComponentSpecsInner componentDefRef(String componentDefRef) {
    
    this.componentDefRef = componentDefRef;
    return this;
  }

   /**
   * References a ClusterComponentDefinition defined in the &#x60;clusterDefinition.spec.componentDef&#x60; field. Must comply with the IANA service naming rule.   Deprecated since v0.9, because defining Components in &#x60;clusterDefinition.spec.componentDef&#x60; field has been deprecated. This field is replaced by the &#x60;componentDef&#x60; field, use &#x60;componentDef&#x60; instead. This field is maintained for backward compatibility and its use is discouraged. Existing usage should be updated to the current preferred approach to avoid compatibility issues in future releases.   TODO +kubebuilder:validation:XValidation:rule&#x3D;\&quot;self &#x3D;&#x3D; oldSelf\&quot;,message&#x3D;\&quot;componentDefRef is immutable\&quot;
   * @return componentDefRef
  **/
  @jakarta.annotation.Nullable
  public String getComponentDefRef() {
    return componentDefRef;
  }


  public void setComponentDefRef(String componentDefRef) {
    this.componentDefRef = componentDefRef;
  }


  public V1alpha1ClusterSpecComponentSpecsInner disableExporter(Boolean disableExporter) {
    
    this.disableExporter = disableExporter;
    return this;
  }

   /**
   * Determines whether metrics exporter information is annotated on the Component&#39;s headless Service.   If set to true, the following annotations will not be patched into the Service:   - \&quot;monitor.kubeblocks.io/path\&quot; - \&quot;monitor.kubeblocks.io/port\&quot; - \&quot;monitor.kubeblocks.io/scheme\&quot;   These annotations allow the Prometheus installed by KubeBlocks to discover and scrape metrics from the exporter.
   * @return disableExporter
  **/
  @jakarta.annotation.Nullable
  public Boolean getDisableExporter() {
    return disableExporter;
  }


  public void setDisableExporter(Boolean disableExporter) {
    this.disableExporter = disableExporter;
  }


  public V1alpha1ClusterSpecComponentSpecsInner enabledLogs(List<String> enabledLogs) {
    
    this.enabledLogs = enabledLogs;
    return this;
  }

  public V1alpha1ClusterSpecComponentSpecsInner addEnabledLogsItem(String enabledLogsItem) {
    if (this.enabledLogs == null) {
      this.enabledLogs = new ArrayList<>();
    }
    this.enabledLogs.add(enabledLogsItem);
    return this;
  }

   /**
   * Specifies which types of logs should be collected for the Component. The log types are defined in the &#x60;componentDefinition.spec.logConfigs&#x60; field with the LogConfig entries.   The elements in the &#x60;enabledLogs&#x60; array correspond to the names of the LogConfig entries. For example, if the &#x60;componentDefinition.spec.logConfigs&#x60; defines LogConfig entries with names \&quot;slow_query_log\&quot; and \&quot;error_log\&quot;, you can enable the collection of these logs by including their names in the &#x60;enabledLogs&#x60; array: &#x60;&#x60;&#x60;yaml enabledLogs: - slow_query_log - error_log &#x60;&#x60;&#x60;
   * @return enabledLogs
  **/
  @jakarta.annotation.Nullable
  public List<String> getEnabledLogs() {
    return enabledLogs;
  }


  public void setEnabledLogs(List<String> enabledLogs) {
    this.enabledLogs = enabledLogs;
  }


  public V1alpha1ClusterSpecComponentSpecsInner instances(List<V1alpha1ClusterSpecComponentSpecsInnerInstancesInner> instances) {
    
    this.instances = instances;
    return this;
  }

  public V1alpha1ClusterSpecComponentSpecsInner addInstancesItem(V1alpha1ClusterSpecComponentSpecsInnerInstancesInner instancesItem) {
    if (this.instances == null) {
      this.instances = new ArrayList<>();
    }
    this.instances.add(instancesItem);
    return this;
  }

   /**
   * Allows for the customization of configuration values for each instance within a Component. An instance represent a single replica (Pod and associated K8s resources like PVCs, Services, and ConfigMaps). While instances typically share a common configuration as defined in the ClusterComponentSpec, they can require unique settings in various scenarios:   For example: - A database Component might require different resource allocations for primary and secondary instances, with primaries needing more resources. - During a rolling upgrade, a Component may first update the image for one or a few instances, and then update the remaining instances after verifying that the updated instances are functioning correctly.   InstanceTemplate allows for specifying these unique configurations per instance. Each instance&#39;s name is constructed using the pattern: $(component.name)-$(template.name)-$(ordinal), starting with an ordinal of 0. It is crucial to maintain unique names for each InstanceTemplate to avoid conflicts.   The sum of replicas across all InstanceTemplates should not exceed the total number of replicas specified for the Component. Any remaining replicas will be generated using the default template and will follow the default naming rules.
   * @return instances
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ClusterSpecComponentSpecsInnerInstancesInner> getInstances() {
    return instances;
  }


  public void setInstances(List<V1alpha1ClusterSpecComponentSpecsInnerInstancesInner> instances) {
    this.instances = instances;
  }


  public V1alpha1ClusterSpecComponentSpecsInner issuer(V1alpha1ClusterSpecComponentSpecsInnerIssuer issuer) {
    
    this.issuer = issuer;
    return this;
  }

   /**
   * Get issuer
   * @return issuer
  **/
  @jakarta.annotation.Nullable
  public V1alpha1ClusterSpecComponentSpecsInnerIssuer getIssuer() {
    return issuer;
  }


  public void setIssuer(V1alpha1ClusterSpecComponentSpecsInnerIssuer issuer) {
    this.issuer = issuer;
  }


  public V1alpha1ClusterSpecComponentSpecsInner monitor(Boolean monitor) {
    
    this.monitor = monitor;
    return this;
  }

   /**
   * Deprecated since v0.9 Determines whether metrics exporter information is annotated on the Component&#39;s headless Service.   If set to true, the following annotations will be patched into the Service:   - \&quot;monitor.kubeblocks.io/path\&quot; - \&quot;monitor.kubeblocks.io/port\&quot; - \&quot;monitor.kubeblocks.io/scheme\&quot;   These annotations allow the Prometheus installed by KubeBlocks to discover and scrape metrics from the exporter.
   * @return monitor
  **/
  @jakarta.annotation.Nullable
  public Boolean getMonitor() {
    return monitor;
  }


  public void setMonitor(Boolean monitor) {
    this.monitor = monitor;
  }


  public V1alpha1ClusterSpecComponentSpecsInner name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Specifies the Component&#39;s name. It&#39;s part of the Service DNS name and must comply with the IANA service naming rule. The name is optional when ClusterComponentSpec is used as a template (e.g., in &#x60;shardingSpec&#x60;), but required otherwise.   TODO +kubebuilder:validation:XValidation:rule&#x3D;\&quot;self &#x3D;&#x3D; oldSelf\&quot;,message&#x3D;\&quot;name is immutable\&quot;
   * @return name
  **/
  @jakarta.annotation.Nullable
  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public V1alpha1ClusterSpecComponentSpecsInner offlineInstances(List<String> offlineInstances) {
    
    this.offlineInstances = offlineInstances;
    return this;
  }

  public V1alpha1ClusterSpecComponentSpecsInner addOfflineInstancesItem(String offlineInstancesItem) {
    if (this.offlineInstances == null) {
      this.offlineInstances = new ArrayList<>();
    }
    this.offlineInstances.add(offlineInstancesItem);
    return this;
  }

   /**
   * Specifies the names of instances to be transitioned to offline status.   Marking an instance as offline results in the following:   1. The associated Pod is stopped, and its PersistentVolumeClaim (PVC) is retained for potential future reuse or data recovery, but it is no longer actively used. 2. The ordinal number assigned to this instance is preserved, ensuring it remains unique and avoiding conflicts with new instances.   Setting instances to offline allows for a controlled scale-in process, preserving their data and maintaining ordinal consistency within the Cluster. Note that offline instances and their associated resources, such as PVCs, are not automatically deleted. The administrator must manually manage the cleanup and removal of these resources when they are no longer needed.
   * @return offlineInstances
  **/
  @jakarta.annotation.Nullable
  public List<String> getOfflineInstances() {
    return offlineInstances;
  }


  public void setOfflineInstances(List<String> offlineInstances) {
    this.offlineInstances = offlineInstances;
  }


  public V1alpha1ClusterSpecComponentSpecsInner replicas(Integer replicas) {
    
    this.replicas = replicas;
    return this;
  }

   /**
   * Specifies the desired number of replicas in the Component for enhancing availability and durability, or load balancing.
   * minimum: 0
   * @return replicas
  **/
  @jakarta.annotation.Nonnull
  public Integer getReplicas() {
    return replicas;
  }


  public void setReplicas(Integer replicas) {
    this.replicas = replicas;
  }


  public V1alpha1ClusterSpecComponentSpecsInner resources(Object resources) {
    
    this.resources = resources;
    return this;
  }

   /**
   * Specifies the resources required by the Component. It allows defining the CPU, memory requirements and limits for the Component&#39;s containers.
   * @return resources
  **/
  @jakarta.annotation.Nullable
  public Object getResources() {
    return resources;
  }


  public void setResources(Object resources) {
    this.resources = resources;
  }


  public V1alpha1ClusterSpecComponentSpecsInner serviceAccountName(String serviceAccountName) {
    
    this.serviceAccountName = serviceAccountName;
    return this;
  }

   /**
   * Specifies the name of the ServiceAccount required by the running Component. This ServiceAccount is used to grant necessary permissions for the Component&#39;s Pods to interact with other Kubernetes resources, such as modifying Pod labels or sending events.   Defaults: If not specified, KubeBlocks automatically assigns a default ServiceAccount named \&quot;kb-{cluster.name}\&quot;, bound to a default role installed together with KubeBlocks.   Future Changes: Future versions might change the default ServiceAccount creation strategy to one per Component, potentially revising the naming to \&quot;kb-{cluster.name}-{component.name}\&quot;.   Users can override the automatic ServiceAccount assignment by explicitly setting the name of an existed ServiceAccount in this field.
   * @return serviceAccountName
  **/
  @jakarta.annotation.Nullable
  public String getServiceAccountName() {
    return serviceAccountName;
  }


  public void setServiceAccountName(String serviceAccountName) {
    this.serviceAccountName = serviceAccountName;
  }


  public V1alpha1ClusterSpecComponentSpecsInner serviceRefs(List<V1alpha1ClusterSpecComponentSpecsInnerServiceRefsInner> serviceRefs) {
    
    this.serviceRefs = serviceRefs;
    return this;
  }

  public V1alpha1ClusterSpecComponentSpecsInner addServiceRefsItem(V1alpha1ClusterSpecComponentSpecsInnerServiceRefsInner serviceRefsItem) {
    if (this.serviceRefs == null) {
      this.serviceRefs = new ArrayList<>();
    }
    this.serviceRefs.add(serviceRefsItem);
    return this;
  }

   /**
   * Defines a list of ServiceRef for a Component, enabling access to both external services and Services provided by other Clusters.   Types of services:   - External services: Not managed by KubeBlocks or managed by a different KubeBlocks operator; Require a ServiceDescriptor for connection details. - Services provided by a Cluster: Managed by the same KubeBlocks operator; identified using Cluster, Component and Service names.   ServiceRefs with identical &#x60;serviceRef.name&#x60; in the same Cluster are considered the same.   Example: &#x60;&#x60;&#x60;yaml serviceRefs: - name: \&quot;redis-sentinel\&quot; serviceDescriptor: name: \&quot;external-redis-sentinel\&quot; - name: \&quot;postgres-cluster\&quot; clusterServiceSelector: cluster: \&quot;my-postgres-cluster\&quot; service: component: \&quot;postgresql\&quot; &#x60;&#x60;&#x60; The example above includes ServiceRefs to an external Redis Sentinel service and a PostgreSQL Cluster.
   * @return serviceRefs
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ClusterSpecComponentSpecsInnerServiceRefsInner> getServiceRefs() {
    return serviceRefs;
  }


  public void setServiceRefs(List<V1alpha1ClusterSpecComponentSpecsInnerServiceRefsInner> serviceRefs) {
    this.serviceRefs = serviceRefs;
  }


  public V1alpha1ClusterSpecComponentSpecsInner serviceVersion(String serviceVersion) {
    
    this.serviceVersion = serviceVersion;
    return this;
  }

   /**
   * ServiceVersion specifies the version of the Service expected to be provisioned by this Component. The version should follow the syntax and semantics of the \&quot;Semantic Versioning\&quot; specification (http://semver.org/). If no version is specified, the latest available version will be used.
   * @return serviceVersion
  **/
  @jakarta.annotation.Nullable
  public String getServiceVersion() {
    return serviceVersion;
  }


  public void setServiceVersion(String serviceVersion) {
    this.serviceVersion = serviceVersion;
  }


  public V1alpha1ClusterSpecComponentSpecsInner services(List<V1alpha1ClusterSpecComponentSpecsInnerServicesInner> services) {
    
    this.services = services;
    return this;
  }

  public V1alpha1ClusterSpecComponentSpecsInner addServicesItem(V1alpha1ClusterSpecComponentSpecsInnerServicesInner servicesItem) {
    if (this.services == null) {
      this.services = new ArrayList<>();
    }
    this.services.add(servicesItem);
    return this;
  }

   /**
   * Overrides services defined in referenced ComponentDefinition and expose endpoints that can be accessed by clients.
   * @return services
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ClusterSpecComponentSpecsInnerServicesInner> getServices() {
    return services;
  }


  public void setServices(List<V1alpha1ClusterSpecComponentSpecsInnerServicesInner> services) {
    this.services = services;
  }


  public V1alpha1ClusterSpecComponentSpecsInner switchPolicy(V1alpha1ClusterSpecComponentSpecsInnerSwitchPolicy switchPolicy) {
    
    this.switchPolicy = switchPolicy;
    return this;
  }

   /**
   * Get switchPolicy
   * @return switchPolicy
  **/
  @jakarta.annotation.Nullable
  public V1alpha1ClusterSpecComponentSpecsInnerSwitchPolicy getSwitchPolicy() {
    return switchPolicy;
  }


  public void setSwitchPolicy(V1alpha1ClusterSpecComponentSpecsInnerSwitchPolicy switchPolicy) {
    this.switchPolicy = switchPolicy;
  }


  public V1alpha1ClusterSpecComponentSpecsInner systemAccounts(List<V1alpha1ClusterSpecComponentSpecsInnerSystemAccountsInner> systemAccounts) {
    
    this.systemAccounts = systemAccounts;
    return this;
  }

  public V1alpha1ClusterSpecComponentSpecsInner addSystemAccountsItem(V1alpha1ClusterSpecComponentSpecsInnerSystemAccountsInner systemAccountsItem) {
    if (this.systemAccounts == null) {
      this.systemAccounts = new ArrayList<>();
    }
    this.systemAccounts.add(systemAccountsItem);
    return this;
  }

   /**
   * Overrides system accounts defined in referenced ComponentDefinition.
   * @return systemAccounts
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ClusterSpecComponentSpecsInnerSystemAccountsInner> getSystemAccounts() {
    return systemAccounts;
  }


  public void setSystemAccounts(List<V1alpha1ClusterSpecComponentSpecsInnerSystemAccountsInner> systemAccounts) {
    this.systemAccounts = systemAccounts;
  }


  public V1alpha1ClusterSpecComponentSpecsInner tls(Boolean tls) {
    
    this.tls = tls;
    return this;
  }

   /**
   * A boolean flag that indicates whether the Component should use Transport Layer Security (TLS) for secure communication. When set to true, the Component will be configured to use TLS encryption for its network connections. This ensures that the data transmitted between the Component and its clients or other Components is encrypted and protected from unauthorized access. If TLS is enabled, the Component may require additional configuration, such as specifying TLS certificates and keys, to properly set up the secure communication channel.
   * @return tls
  **/
  @jakarta.annotation.Nullable
  public Boolean getTls() {
    return tls;
  }


  public void setTls(Boolean tls) {
    this.tls = tls;
  }


  public V1alpha1ClusterSpecComponentSpecsInner tolerations(Object tolerations) {
    
    this.tolerations = tolerations;
    return this;
  }

   /**
   * Allows Pods to be scheduled onto nodes with matching taints. Each toleration in the array allows the Pod to tolerate node taints based on specified &#x60;key&#x60;, &#x60;value&#x60;, &#x60;effect&#x60;, and &#x60;operator&#x60;.   - The &#x60;key&#x60;, &#x60;value&#x60;, and &#x60;effect&#x60; identify the taint that the toleration matches. - The &#x60;operator&#x60; determines how the toleration matches the taint.   Pods with matching tolerations are allowed to be scheduled on tainted nodes, typically reserved for specific purposes.
   * @return tolerations
  **/
  @jakarta.annotation.Nullable
  public Object getTolerations() {
    return tolerations;
  }


  public void setTolerations(Object tolerations) {
    this.tolerations = tolerations;
  }


  public V1alpha1ClusterSpecComponentSpecsInner updateStrategy(UpdateStrategyEnum updateStrategy) {
    
    this.updateStrategy = updateStrategy;
    return this;
  }

   /**
   * Defines the update strategy for the Component.   Deprecated since v0.9. This field is maintained for backward compatibility and its use is discouraged. Existing usage should be updated to the current preferred approach to avoid compatibility issues in future releases.
   * @return updateStrategy
  **/
  @jakarta.annotation.Nullable
  public UpdateStrategyEnum getUpdateStrategy() {
    return updateStrategy;
  }


  public void setUpdateStrategy(UpdateStrategyEnum updateStrategy) {
    this.updateStrategy = updateStrategy;
  }


  public V1alpha1ClusterSpecComponentSpecsInner userResourceRefs(V1alpha1ClusterSpecComponentSpecsInnerUserResourceRefs userResourceRefs) {
    
    this.userResourceRefs = userResourceRefs;
    return this;
  }

   /**
   * Get userResourceRefs
   * @return userResourceRefs
  **/
  @jakarta.annotation.Nullable
  public V1alpha1ClusterSpecComponentSpecsInnerUserResourceRefs getUserResourceRefs() {
    return userResourceRefs;
  }


  public void setUserResourceRefs(V1alpha1ClusterSpecComponentSpecsInnerUserResourceRefs userResourceRefs) {
    this.userResourceRefs = userResourceRefs;
  }


  public V1alpha1ClusterSpecComponentSpecsInner volumeClaimTemplates(List<V1alpha1ClusterSpecComponentSpecsInnerInstancesInnerVolumeClaimTemplatesInner> volumeClaimTemplates) {
    
    this.volumeClaimTemplates = volumeClaimTemplates;
    return this;
  }

  public V1alpha1ClusterSpecComponentSpecsInner addVolumeClaimTemplatesItem(V1alpha1ClusterSpecComponentSpecsInnerInstancesInnerVolumeClaimTemplatesInner volumeClaimTemplatesItem) {
    if (this.volumeClaimTemplates == null) {
      this.volumeClaimTemplates = new ArrayList<>();
    }
    this.volumeClaimTemplates.add(volumeClaimTemplatesItem);
    return this;
  }

   /**
   * Specifies a list of PersistentVolumeClaim templates that represent the storage requirements for the Component. Each template specifies the desired characteristics of a persistent volume, such as storage class, size, and access modes. These templates are used to dynamically provision persistent volumes for the Component.
   * @return volumeClaimTemplates
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ClusterSpecComponentSpecsInnerInstancesInnerVolumeClaimTemplatesInner> getVolumeClaimTemplates() {
    return volumeClaimTemplates;
  }


  public void setVolumeClaimTemplates(List<V1alpha1ClusterSpecComponentSpecsInnerInstancesInnerVolumeClaimTemplatesInner> volumeClaimTemplates) {
    this.volumeClaimTemplates = volumeClaimTemplates;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1ClusterSpecComponentSpecsInner v1alpha1ClusterSpecComponentSpecsInner = (V1alpha1ClusterSpecComponentSpecsInner) o;
    return Objects.equals(this.affinity, v1alpha1ClusterSpecComponentSpecsInner.affinity) &&
        Objects.equals(this.classDefRef, v1alpha1ClusterSpecComponentSpecsInner.classDefRef) &&
        Objects.equals(this.componentDef, v1alpha1ClusterSpecComponentSpecsInner.componentDef) &&
        Objects.equals(this.componentDefRef, v1alpha1ClusterSpecComponentSpecsInner.componentDefRef) &&
        Objects.equals(this.disableExporter, v1alpha1ClusterSpecComponentSpecsInner.disableExporter) &&
        Objects.equals(this.enabledLogs, v1alpha1ClusterSpecComponentSpecsInner.enabledLogs) &&
        Objects.equals(this.instances, v1alpha1ClusterSpecComponentSpecsInner.instances) &&
        Objects.equals(this.issuer, v1alpha1ClusterSpecComponentSpecsInner.issuer) &&
        Objects.equals(this.monitor, v1alpha1ClusterSpecComponentSpecsInner.monitor) &&
        Objects.equals(this.name, v1alpha1ClusterSpecComponentSpecsInner.name) &&
        Objects.equals(this.offlineInstances, v1alpha1ClusterSpecComponentSpecsInner.offlineInstances) &&
        Objects.equals(this.replicas, v1alpha1ClusterSpecComponentSpecsInner.replicas) &&
        Objects.equals(this.resources, v1alpha1ClusterSpecComponentSpecsInner.resources) &&
        Objects.equals(this.serviceAccountName, v1alpha1ClusterSpecComponentSpecsInner.serviceAccountName) &&
        Objects.equals(this.serviceRefs, v1alpha1ClusterSpecComponentSpecsInner.serviceRefs) &&
        Objects.equals(this.serviceVersion, v1alpha1ClusterSpecComponentSpecsInner.serviceVersion) &&
        Objects.equals(this.services, v1alpha1ClusterSpecComponentSpecsInner.services) &&
        Objects.equals(this.switchPolicy, v1alpha1ClusterSpecComponentSpecsInner.switchPolicy) &&
        Objects.equals(this.systemAccounts, v1alpha1ClusterSpecComponentSpecsInner.systemAccounts) &&
        Objects.equals(this.tls, v1alpha1ClusterSpecComponentSpecsInner.tls) &&
        Objects.equals(this.tolerations, v1alpha1ClusterSpecComponentSpecsInner.tolerations) &&
        Objects.equals(this.updateStrategy, v1alpha1ClusterSpecComponentSpecsInner.updateStrategy) &&
        Objects.equals(this.userResourceRefs, v1alpha1ClusterSpecComponentSpecsInner.userResourceRefs) &&
        Objects.equals(this.volumeClaimTemplates, v1alpha1ClusterSpecComponentSpecsInner.volumeClaimTemplates);
  }

  @Override
  public int hashCode() {
    return Objects.hash(affinity, classDefRef, componentDef, componentDefRef, disableExporter, enabledLogs, instances, issuer, monitor, name, offlineInstances, replicas, resources, serviceAccountName, serviceRefs, serviceVersion, services, switchPolicy, systemAccounts, tls, tolerations, updateStrategy, userResourceRefs, volumeClaimTemplates);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1ClusterSpecComponentSpecsInner {\n");
    sb.append("    affinity: ").append(toIndentedString(affinity)).append("\n");
    sb.append("    classDefRef: ").append(toIndentedString(classDefRef)).append("\n");
    sb.append("    componentDef: ").append(toIndentedString(componentDef)).append("\n");
    sb.append("    componentDefRef: ").append(toIndentedString(componentDefRef)).append("\n");
    sb.append("    disableExporter: ").append(toIndentedString(disableExporter)).append("\n");
    sb.append("    enabledLogs: ").append(toIndentedString(enabledLogs)).append("\n");
    sb.append("    instances: ").append(toIndentedString(instances)).append("\n");
    sb.append("    issuer: ").append(toIndentedString(issuer)).append("\n");
    sb.append("    monitor: ").append(toIndentedString(monitor)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    offlineInstances: ").append(toIndentedString(offlineInstances)).append("\n");
    sb.append("    replicas: ").append(toIndentedString(replicas)).append("\n");
    sb.append("    resources: ").append(toIndentedString(resources)).append("\n");
    sb.append("    serviceAccountName: ").append(toIndentedString(serviceAccountName)).append("\n");
    sb.append("    serviceRefs: ").append(toIndentedString(serviceRefs)).append("\n");
    sb.append("    serviceVersion: ").append(toIndentedString(serviceVersion)).append("\n");
    sb.append("    services: ").append(toIndentedString(services)).append("\n");
    sb.append("    switchPolicy: ").append(toIndentedString(switchPolicy)).append("\n");
    sb.append("    systemAccounts: ").append(toIndentedString(systemAccounts)).append("\n");
    sb.append("    tls: ").append(toIndentedString(tls)).append("\n");
    sb.append("    tolerations: ").append(toIndentedString(tolerations)).append("\n");
    sb.append("    updateStrategy: ").append(toIndentedString(updateStrategy)).append("\n");
    sb.append("    userResourceRefs: ").append(toIndentedString(userResourceRefs)).append("\n");
    sb.append("    volumeClaimTemplates: ").append(toIndentedString(volumeClaimTemplates)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("affinity");
    openapiFields.add("classDefRef");
    openapiFields.add("componentDef");
    openapiFields.add("componentDefRef");
    openapiFields.add("disableExporter");
    openapiFields.add("enabledLogs");
    openapiFields.add("instances");
    openapiFields.add("issuer");
    openapiFields.add("monitor");
    openapiFields.add("name");
    openapiFields.add("offlineInstances");
    openapiFields.add("replicas");
    openapiFields.add("resources");
    openapiFields.add("serviceAccountName");
    openapiFields.add("serviceRefs");
    openapiFields.add("serviceVersion");
    openapiFields.add("services");
    openapiFields.add("switchPolicy");
    openapiFields.add("systemAccounts");
    openapiFields.add("tls");
    openapiFields.add("tolerations");
    openapiFields.add("updateStrategy");
    openapiFields.add("userResourceRefs");
    openapiFields.add("volumeClaimTemplates");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("replicas");
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1alpha1ClusterSpecComponentSpecsInner
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1alpha1ClusterSpecComponentSpecsInner.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1alpha1ClusterSpecComponentSpecsInner is not found in the empty JSON string", V1alpha1ClusterSpecComponentSpecsInner.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1alpha1ClusterSpecComponentSpecsInner.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1alpha1ClusterSpecComponentSpecsInner` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : V1alpha1ClusterSpecComponentSpecsInner.openapiRequiredFields) {
        if (jsonObj.get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonObj.toString()));
        }
      }
      // validate the optional field `affinity`
      if (jsonObj.get("affinity") != null && !jsonObj.get("affinity").isJsonNull()) {
        V1alpha1ClusterSpecComponentSpecsInnerAffinity.validateJsonObject(jsonObj.getAsJsonObject("affinity"));
      }
      // validate the optional field `classDefRef`
      if (jsonObj.get("classDefRef") != null && !jsonObj.get("classDefRef").isJsonNull()) {
        V1alpha1ClusterSpecComponentSpecsInnerClassDefRef.validateJsonObject(jsonObj.getAsJsonObject("classDefRef"));
      }
      if ((jsonObj.get("componentDef") != null && !jsonObj.get("componentDef").isJsonNull()) && !jsonObj.get("componentDef").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `componentDef` to be a primitive type in the JSON string but got `%s`", jsonObj.get("componentDef").toString()));
      }
      if ((jsonObj.get("componentDefRef") != null && !jsonObj.get("componentDefRef").isJsonNull()) && !jsonObj.get("componentDefRef").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `componentDefRef` to be a primitive type in the JSON string but got `%s`", jsonObj.get("componentDefRef").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("enabledLogs") != null && !jsonObj.get("enabledLogs").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `enabledLogs` to be an array in the JSON string but got `%s`", jsonObj.get("enabledLogs").toString()));
      }
      if (jsonObj.get("instances") != null && !jsonObj.get("instances").isJsonNull()) {
        JsonArray jsonArrayinstances = jsonObj.getAsJsonArray("instances");
        if (jsonArrayinstances != null) {
          // ensure the json data is an array
          if (!jsonObj.get("instances").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `instances` to be an array in the JSON string but got `%s`", jsonObj.get("instances").toString()));
          }

          // validate the optional field `instances` (array)
          for (int i = 0; i < jsonArrayinstances.size(); i++) {
            V1alpha1ClusterSpecComponentSpecsInnerInstancesInner.validateJsonObject(jsonArrayinstances.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `issuer`
      if (jsonObj.get("issuer") != null && !jsonObj.get("issuer").isJsonNull()) {
        V1alpha1ClusterSpecComponentSpecsInnerIssuer.validateJsonObject(jsonObj.getAsJsonObject("issuer"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("offlineInstances") != null && !jsonObj.get("offlineInstances").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `offlineInstances` to be an array in the JSON string but got `%s`", jsonObj.get("offlineInstances").toString()));
      }
      if ((jsonObj.get("serviceAccountName") != null && !jsonObj.get("serviceAccountName").isJsonNull()) && !jsonObj.get("serviceAccountName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceAccountName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceAccountName").toString()));
      }
      if (jsonObj.get("serviceRefs") != null && !jsonObj.get("serviceRefs").isJsonNull()) {
        JsonArray jsonArrayserviceRefs = jsonObj.getAsJsonArray("serviceRefs");
        if (jsonArrayserviceRefs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("serviceRefs").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `serviceRefs` to be an array in the JSON string but got `%s`", jsonObj.get("serviceRefs").toString()));
          }

          // validate the optional field `serviceRefs` (array)
          for (int i = 0; i < jsonArrayserviceRefs.size(); i++) {
            V1alpha1ClusterSpecComponentSpecsInnerServiceRefsInner.validateJsonObject(jsonArrayserviceRefs.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("serviceVersion") != null && !jsonObj.get("serviceVersion").isJsonNull()) && !jsonObj.get("serviceVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `serviceVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("serviceVersion").toString()));
      }
      if (jsonObj.get("services") != null && !jsonObj.get("services").isJsonNull()) {
        JsonArray jsonArrayservices = jsonObj.getAsJsonArray("services");
        if (jsonArrayservices != null) {
          // ensure the json data is an array
          if (!jsonObj.get("services").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `services` to be an array in the JSON string but got `%s`", jsonObj.get("services").toString()));
          }

          // validate the optional field `services` (array)
          for (int i = 0; i < jsonArrayservices.size(); i++) {
            V1alpha1ClusterSpecComponentSpecsInnerServicesInner.validateJsonObject(jsonArrayservices.get(i).getAsJsonObject());
          };
        }
      }
      // validate the optional field `switchPolicy`
      if (jsonObj.get("switchPolicy") != null && !jsonObj.get("switchPolicy").isJsonNull()) {
        V1alpha1ClusterSpecComponentSpecsInnerSwitchPolicy.validateJsonObject(jsonObj.getAsJsonObject("switchPolicy"));
      }
      if (jsonObj.get("systemAccounts") != null && !jsonObj.get("systemAccounts").isJsonNull()) {
        JsonArray jsonArraysystemAccounts = jsonObj.getAsJsonArray("systemAccounts");
        if (jsonArraysystemAccounts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("systemAccounts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `systemAccounts` to be an array in the JSON string but got `%s`", jsonObj.get("systemAccounts").toString()));
          }

          // validate the optional field `systemAccounts` (array)
          for (int i = 0; i < jsonArraysystemAccounts.size(); i++) {
            V1alpha1ClusterSpecComponentSpecsInnerSystemAccountsInner.validateJsonObject(jsonArraysystemAccounts.get(i).getAsJsonObject());
          };
        }
      }
      if ((jsonObj.get("updateStrategy") != null && !jsonObj.get("updateStrategy").isJsonNull()) && !jsonObj.get("updateStrategy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateStrategy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateStrategy").toString()));
      }
      // validate the optional field `userResourceRefs`
      if (jsonObj.get("userResourceRefs") != null && !jsonObj.get("userResourceRefs").isJsonNull()) {
        V1alpha1ClusterSpecComponentSpecsInnerUserResourceRefs.validateJsonObject(jsonObj.getAsJsonObject("userResourceRefs"));
      }
      if (jsonObj.get("volumeClaimTemplates") != null && !jsonObj.get("volumeClaimTemplates").isJsonNull()) {
        JsonArray jsonArrayvolumeClaimTemplates = jsonObj.getAsJsonArray("volumeClaimTemplates");
        if (jsonArrayvolumeClaimTemplates != null) {
          // ensure the json data is an array
          if (!jsonObj.get("volumeClaimTemplates").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `volumeClaimTemplates` to be an array in the JSON string but got `%s`", jsonObj.get("volumeClaimTemplates").toString()));
          }

          // validate the optional field `volumeClaimTemplates` (array)
          for (int i = 0; i < jsonArrayvolumeClaimTemplates.size(); i++) {
            V1alpha1ClusterSpecComponentSpecsInnerInstancesInnerVolumeClaimTemplatesInner.validateJsonObject(jsonArrayvolumeClaimTemplates.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1alpha1ClusterSpecComponentSpecsInner.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1alpha1ClusterSpecComponentSpecsInner' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1alpha1ClusterSpecComponentSpecsInner> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1alpha1ClusterSpecComponentSpecsInner.class));

       return (TypeAdapter<T>) new TypeAdapter<V1alpha1ClusterSpecComponentSpecsInner>() {
           @Override
           public void write(JsonWriter out, V1alpha1ClusterSpecComponentSpecsInner value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1alpha1ClusterSpecComponentSpecsInner read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1alpha1ClusterSpecComponentSpecsInner given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1alpha1ClusterSpecComponentSpecsInner
  * @throws IOException if the JSON string is invalid with respect to V1alpha1ClusterSpecComponentSpecsInner
  */
  public static V1alpha1ClusterSpecComponentSpecsInner fromJson(String jsonString) throws IOException {
    return new JSON().getGson().fromJson(jsonString, V1alpha1ClusterSpecComponentSpecsInner.class);
  }

 /**
  * Convert an instance of V1alpha1ClusterSpecComponentSpecsInner to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return new JSON().getGson().toJson(this);
  }
}

