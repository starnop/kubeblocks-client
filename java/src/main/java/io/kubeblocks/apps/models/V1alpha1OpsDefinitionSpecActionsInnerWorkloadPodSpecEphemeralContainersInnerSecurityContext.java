/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.27.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.kubeblocks.apps.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubeblocks.apps.models.V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextCapabilities;
import io.kubeblocks.apps.models.V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeLinuxOptions;
import io.kubeblocks.apps.models.V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeccompProfile;
import io.kubeblocks.apps.models.V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextWindowsOptions;
import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * Optional: SecurityContext defines the security options the ephemeral container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-06-13T15:59:08.817252Z[Etc/UTC]")
public class V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext {
  public static final String SERIALIZED_NAME_ALLOW_PRIVILEGE_ESCALATION = "allowPrivilegeEscalation";
  @SerializedName(SERIALIZED_NAME_ALLOW_PRIVILEGE_ESCALATION)
  private Boolean allowPrivilegeEscalation;

  public static final String SERIALIZED_NAME_CAPABILITIES = "capabilities";
  @SerializedName(SERIALIZED_NAME_CAPABILITIES)
  private V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextCapabilities capabilities;

  public static final String SERIALIZED_NAME_PRIVILEGED = "privileged";
  @SerializedName(SERIALIZED_NAME_PRIVILEGED)
  private Boolean privileged;

  public static final String SERIALIZED_NAME_PROC_MOUNT = "procMount";
  @SerializedName(SERIALIZED_NAME_PROC_MOUNT)
  private String procMount;

  public static final String SERIALIZED_NAME_READ_ONLY_ROOT_FILESYSTEM = "readOnlyRootFilesystem";
  @SerializedName(SERIALIZED_NAME_READ_ONLY_ROOT_FILESYSTEM)
  private Boolean readOnlyRootFilesystem;

  public static final String SERIALIZED_NAME_RUN_AS_GROUP = "runAsGroup";
  @SerializedName(SERIALIZED_NAME_RUN_AS_GROUP)
  private Long runAsGroup;

  public static final String SERIALIZED_NAME_RUN_AS_NON_ROOT = "runAsNonRoot";
  @SerializedName(SERIALIZED_NAME_RUN_AS_NON_ROOT)
  private Boolean runAsNonRoot;

  public static final String SERIALIZED_NAME_RUN_AS_USER = "runAsUser";
  @SerializedName(SERIALIZED_NAME_RUN_AS_USER)
  private Long runAsUser;

  public static final String SERIALIZED_NAME_SE_LINUX_OPTIONS = "seLinuxOptions";
  @SerializedName(SERIALIZED_NAME_SE_LINUX_OPTIONS)
  private V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeLinuxOptions seLinuxOptions;

  public static final String SERIALIZED_NAME_SECCOMP_PROFILE = "seccompProfile";
  @SerializedName(SERIALIZED_NAME_SECCOMP_PROFILE)
  private V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeccompProfile seccompProfile;

  public static final String SERIALIZED_NAME_WINDOWS_OPTIONS = "windowsOptions";
  @SerializedName(SERIALIZED_NAME_WINDOWS_OPTIONS)
  private V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextWindowsOptions windowsOptions;

  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext() {
  }

  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext allowPrivilegeEscalation(Boolean allowPrivilegeEscalation) {
    
    this.allowPrivilegeEscalation = allowPrivilegeEscalation;
    return this;
  }

   /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
   * @return allowPrivilegeEscalation
  **/
  @jakarta.annotation.Nullable
  public Boolean getAllowPrivilegeEscalation() {
    return allowPrivilegeEscalation;
  }


  public void setAllowPrivilegeEscalation(Boolean allowPrivilegeEscalation) {
    this.allowPrivilegeEscalation = allowPrivilegeEscalation;
  }


  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext capabilities(V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextCapabilities capabilities) {
    
    this.capabilities = capabilities;
    return this;
  }

   /**
   * Get capabilities
   * @return capabilities
  **/
  @jakarta.annotation.Nullable
  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextCapabilities getCapabilities() {
    return capabilities;
  }


  public void setCapabilities(V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextCapabilities capabilities) {
    this.capabilities = capabilities;
  }


  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext privileged(Boolean privileged) {
    
    this.privileged = privileged;
    return this;
  }

   /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
   * @return privileged
  **/
  @jakarta.annotation.Nullable
  public Boolean getPrivileged() {
    return privileged;
  }


  public void setPrivileged(Boolean privileged) {
    this.privileged = privileged;
  }


  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext procMount(String procMount) {
    
    this.procMount = procMount;
    return this;
  }

   /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
   * @return procMount
  **/
  @jakarta.annotation.Nullable
  public String getProcMount() {
    return procMount;
  }


  public void setProcMount(String procMount) {
    this.procMount = procMount;
  }


  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext readOnlyRootFilesystem(Boolean readOnlyRootFilesystem) {
    
    this.readOnlyRootFilesystem = readOnlyRootFilesystem;
    return this;
  }

   /**
   * Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
   * @return readOnlyRootFilesystem
  **/
  @jakarta.annotation.Nullable
  public Boolean getReadOnlyRootFilesystem() {
    return readOnlyRootFilesystem;
  }


  public void setReadOnlyRootFilesystem(Boolean readOnlyRootFilesystem) {
    this.readOnlyRootFilesystem = readOnlyRootFilesystem;
  }


  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext runAsGroup(Long runAsGroup) {
    
    this.runAsGroup = runAsGroup;
    return this;
  }

   /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @return runAsGroup
  **/
  @jakarta.annotation.Nullable
  public Long getRunAsGroup() {
    return runAsGroup;
  }


  public void setRunAsGroup(Long runAsGroup) {
    this.runAsGroup = runAsGroup;
  }


  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext runAsNonRoot(Boolean runAsNonRoot) {
    
    this.runAsNonRoot = runAsNonRoot;
    return this;
  }

   /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @return runAsNonRoot
  **/
  @jakarta.annotation.Nullable
  public Boolean getRunAsNonRoot() {
    return runAsNonRoot;
  }


  public void setRunAsNonRoot(Boolean runAsNonRoot) {
    this.runAsNonRoot = runAsNonRoot;
  }


  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext runAsUser(Long runAsUser) {
    
    this.runAsUser = runAsUser;
    return this;
  }

   /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
   * @return runAsUser
  **/
  @jakarta.annotation.Nullable
  public Long getRunAsUser() {
    return runAsUser;
  }


  public void setRunAsUser(Long runAsUser) {
    this.runAsUser = runAsUser;
  }


  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext seLinuxOptions(V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeLinuxOptions seLinuxOptions) {
    
    this.seLinuxOptions = seLinuxOptions;
    return this;
  }

   /**
   * Get seLinuxOptions
   * @return seLinuxOptions
  **/
  @jakarta.annotation.Nullable
  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeLinuxOptions getSeLinuxOptions() {
    return seLinuxOptions;
  }


  public void setSeLinuxOptions(V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeLinuxOptions seLinuxOptions) {
    this.seLinuxOptions = seLinuxOptions;
  }


  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext seccompProfile(V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeccompProfile seccompProfile) {
    
    this.seccompProfile = seccompProfile;
    return this;
  }

   /**
   * Get seccompProfile
   * @return seccompProfile
  **/
  @jakarta.annotation.Nullable
  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeccompProfile getSeccompProfile() {
    return seccompProfile;
  }


  public void setSeccompProfile(V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeccompProfile seccompProfile) {
    this.seccompProfile = seccompProfile;
  }


  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext windowsOptions(V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextWindowsOptions windowsOptions) {
    
    this.windowsOptions = windowsOptions;
    return this;
  }

   /**
   * Get windowsOptions
   * @return windowsOptions
  **/
  @jakarta.annotation.Nullable
  public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextWindowsOptions getWindowsOptions() {
    return windowsOptions;
  }


  public void setWindowsOptions(V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextWindowsOptions windowsOptions) {
    this.windowsOptions = windowsOptions;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext = (V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext) o;
    return Objects.equals(this.allowPrivilegeEscalation, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.allowPrivilegeEscalation) &&
        Objects.equals(this.capabilities, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.capabilities) &&
        Objects.equals(this.privileged, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.privileged) &&
        Objects.equals(this.procMount, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.procMount) &&
        Objects.equals(this.readOnlyRootFilesystem, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.readOnlyRootFilesystem) &&
        Objects.equals(this.runAsGroup, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.runAsGroup) &&
        Objects.equals(this.runAsNonRoot, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.runAsNonRoot) &&
        Objects.equals(this.runAsUser, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.runAsUser) &&
        Objects.equals(this.seLinuxOptions, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.seLinuxOptions) &&
        Objects.equals(this.seccompProfile, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.seccompProfile) &&
        Objects.equals(this.windowsOptions, v1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.windowsOptions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowPrivilegeEscalation, capabilities, privileged, procMount, readOnlyRootFilesystem, runAsGroup, runAsNonRoot, runAsUser, seLinuxOptions, seccompProfile, windowsOptions);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext {\n");
    sb.append("    allowPrivilegeEscalation: ").append(toIndentedString(allowPrivilegeEscalation)).append("\n");
    sb.append("    capabilities: ").append(toIndentedString(capabilities)).append("\n");
    sb.append("    privileged: ").append(toIndentedString(privileged)).append("\n");
    sb.append("    procMount: ").append(toIndentedString(procMount)).append("\n");
    sb.append("    readOnlyRootFilesystem: ").append(toIndentedString(readOnlyRootFilesystem)).append("\n");
    sb.append("    runAsGroup: ").append(toIndentedString(runAsGroup)).append("\n");
    sb.append("    runAsNonRoot: ").append(toIndentedString(runAsNonRoot)).append("\n");
    sb.append("    runAsUser: ").append(toIndentedString(runAsUser)).append("\n");
    sb.append("    seLinuxOptions: ").append(toIndentedString(seLinuxOptions)).append("\n");
    sb.append("    seccompProfile: ").append(toIndentedString(seccompProfile)).append("\n");
    sb.append("    windowsOptions: ").append(toIndentedString(windowsOptions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allowPrivilegeEscalation");
    openapiFields.add("capabilities");
    openapiFields.add("privileged");
    openapiFields.add("procMount");
    openapiFields.add("readOnlyRootFilesystem");
    openapiFields.add("runAsGroup");
    openapiFields.add("runAsNonRoot");
    openapiFields.add("runAsUser");
    openapiFields.add("seLinuxOptions");
    openapiFields.add("seccompProfile");
    openapiFields.add("windowsOptions");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext is not found in the empty JSON string", V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      // validate the optional field `capabilities`
      if (jsonObj.get("capabilities") != null && !jsonObj.get("capabilities").isJsonNull()) {
        V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextCapabilities.validateJsonObject(jsonObj.getAsJsonObject("capabilities"));
      }
      if ((jsonObj.get("procMount") != null && !jsonObj.get("procMount").isJsonNull()) && !jsonObj.get("procMount").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `procMount` to be a primitive type in the JSON string but got `%s`", jsonObj.get("procMount").toString()));
      }
      // validate the optional field `seLinuxOptions`
      if (jsonObj.get("seLinuxOptions") != null && !jsonObj.get("seLinuxOptions").isJsonNull()) {
        V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeLinuxOptions.validateJsonObject(jsonObj.getAsJsonObject("seLinuxOptions"));
      }
      // validate the optional field `seccompProfile`
      if (jsonObj.get("seccompProfile") != null && !jsonObj.get("seccompProfile").isJsonNull()) {
        V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextSeccompProfile.validateJsonObject(jsonObj.getAsJsonObject("seccompProfile"));
      }
      // validate the optional field `windowsOptions`
      if (jsonObj.get("windowsOptions") != null && !jsonObj.get("windowsOptions").isJsonNull()) {
        V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecContainersInnerSecurityContextWindowsOptions.validateJsonObject(jsonObj.getAsJsonObject("windowsOptions"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.class));

       return (TypeAdapter<T>) new TypeAdapter<V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext>() {
           @Override
           public void write(JsonWriter out, V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext
  * @throws IOException if the JSON string is invalid with respect to V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext
  */
  public static V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext fromJson(String jsonString) throws IOException {
    return new JSON().getGson().fromJson(jsonString, V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext.class);
  }

 /**
  * Convert an instance of V1alpha1OpsDefinitionSpecActionsInnerWorkloadPodSpecEphemeralContainersInnerSecurityContext to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return new JSON().getGson().toJson(this);
  }
}

