/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.27.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.kubeblocks.apps.models;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubeblocks.apps.models.V1alpha1ComponentDefinitionSpecHostNetworkContainerPortsInner;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import io.kubernetes.client.openapi.JSON;

/**
 * Specifies the host network configuration for the Component.   When &#x60;hostNetwork&#x60; option is enabled, the Pods share the host&#39;s network namespace and can directly access the host&#39;s network interfaces. This means that if multiple Pods need to use the same port, they cannot run on the same host simultaneously due to port conflicts.   The DNSPolicy field in the Pod spec determines how containers within the Pod perform DNS resolution. When using hostNetwork, the operator will set the DNSPolicy to &#39;ClusterFirstWithHostNet&#39;. With this policy, DNS queries will first go through the K8s cluster&#39;s DNS service. If the query fails, it will fall back to the host&#39;s DNS settings.   If set, the DNS policy will be automatically set to \&quot;ClusterFirstWithHostNet\&quot;.
 */
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-06-13T15:59:08.817252Z[Etc/UTC]")
public class V1alpha1ComponentDefinitionSpecHostNetwork {
  public static final String SERIALIZED_NAME_CONTAINER_PORTS = "containerPorts";
  @SerializedName(SERIALIZED_NAME_CONTAINER_PORTS)
  private List<V1alpha1ComponentDefinitionSpecHostNetworkContainerPortsInner> containerPorts;

  public V1alpha1ComponentDefinitionSpecHostNetwork() {
  }

  public V1alpha1ComponentDefinitionSpecHostNetwork containerPorts(List<V1alpha1ComponentDefinitionSpecHostNetworkContainerPortsInner> containerPorts) {
    
    this.containerPorts = containerPorts;
    return this;
  }

  public V1alpha1ComponentDefinitionSpecHostNetwork addContainerPortsItem(V1alpha1ComponentDefinitionSpecHostNetworkContainerPortsInner containerPortsItem) {
    if (this.containerPorts == null) {
      this.containerPorts = new ArrayList<>();
    }
    this.containerPorts.add(containerPortsItem);
    return this;
  }

   /**
   * The list of container ports that are required by the component.
   * @return containerPorts
  **/
  @jakarta.annotation.Nullable
  public List<V1alpha1ComponentDefinitionSpecHostNetworkContainerPortsInner> getContainerPorts() {
    return containerPorts;
  }


  public void setContainerPorts(List<V1alpha1ComponentDefinitionSpecHostNetworkContainerPortsInner> containerPorts) {
    this.containerPorts = containerPorts;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1alpha1ComponentDefinitionSpecHostNetwork v1alpha1ComponentDefinitionSpecHostNetwork = (V1alpha1ComponentDefinitionSpecHostNetwork) o;
    return Objects.equals(this.containerPorts, v1alpha1ComponentDefinitionSpecHostNetwork.containerPorts);
  }

  @Override
  public int hashCode() {
    return Objects.hash(containerPorts);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1alpha1ComponentDefinitionSpecHostNetwork {\n");
    sb.append("    containerPorts: ").append(toIndentedString(containerPorts)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("containerPorts");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to V1alpha1ComponentDefinitionSpecHostNetwork
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!V1alpha1ComponentDefinitionSpecHostNetwork.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in V1alpha1ComponentDefinitionSpecHostNetwork is not found in the empty JSON string", V1alpha1ComponentDefinitionSpecHostNetwork.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!V1alpha1ComponentDefinitionSpecHostNetwork.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `V1alpha1ComponentDefinitionSpecHostNetwork` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if (jsonObj.get("containerPorts") != null && !jsonObj.get("containerPorts").isJsonNull()) {
        JsonArray jsonArraycontainerPorts = jsonObj.getAsJsonArray("containerPorts");
        if (jsonArraycontainerPorts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("containerPorts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `containerPorts` to be an array in the JSON string but got `%s`", jsonObj.get("containerPorts").toString()));
          }

          // validate the optional field `containerPorts` (array)
          for (int i = 0; i < jsonArraycontainerPorts.size(); i++) {
            V1alpha1ComponentDefinitionSpecHostNetworkContainerPortsInner.validateJsonObject(jsonArraycontainerPorts.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!V1alpha1ComponentDefinitionSpecHostNetwork.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'V1alpha1ComponentDefinitionSpecHostNetwork' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<V1alpha1ComponentDefinitionSpecHostNetwork> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(V1alpha1ComponentDefinitionSpecHostNetwork.class));

       return (TypeAdapter<T>) new TypeAdapter<V1alpha1ComponentDefinitionSpecHostNetwork>() {
           @Override
           public void write(JsonWriter out, V1alpha1ComponentDefinitionSpecHostNetwork value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public V1alpha1ComponentDefinitionSpecHostNetwork read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of V1alpha1ComponentDefinitionSpecHostNetwork given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of V1alpha1ComponentDefinitionSpecHostNetwork
  * @throws IOException if the JSON string is invalid with respect to V1alpha1ComponentDefinitionSpecHostNetwork
  */
  public static V1alpha1ComponentDefinitionSpecHostNetwork fromJson(String jsonString) throws IOException {
    return new JSON().getGson().fromJson(jsonString, V1alpha1ComponentDefinitionSpecHostNetwork.class);
  }

 /**
  * Convert an instance of V1alpha1ComponentDefinitionSpecHostNetwork to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return new JSON().getGson().toJson(this);
  }
}

